{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _common = require(\"../../../common\");\n\nvar _renderers = require(\"./renderers\");\n\nvar _types = require(\"../types\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst baseClassName = 'video-streamer';\n\nfunction createVideoStreamerComponent(name, resolveImplementation) {\n  class VideoStreamer extends React.Component {\n    constructor(props) {\n      super(props);\n\n      _defineProperty(this, \"implementation\", void 0);\n\n      _defineProperty(this, \"videoRef\", void 0);\n\n      _defineProperty(this, \"setProperties\", playbackProps => {\n        const applyProperties = this.implementation && this.implementation.applyProperties;\n\n        if (applyProperties) {\n          applyProperties(playbackProps);\n        }\n      });\n\n      _defineProperty(this, \"handleTrackElementDataChange\", trackElementData => {\n        this.setState({\n          trackElementData\n        });\n      });\n\n      _defineProperty(this, \"handleSourceChange\", (nextProps, prevProps) => {\n        const implementation = this.implementation;\n\n        if (implementation) {\n          implementation.startPlaybackSession();\n          implementation.textTrackManager.clear();\n          return implementation.handleSourceChange(nextProps, prevProps).then(() => {\n            implementation.audioTrackManager.handleSourceChange();\n            implementation.textTrackManager.handleSourcePropChange(nextProps);\n          }).catch(err => {\n            implementation.endPlaybackSession('dead');\n            return nextProps.onPlaybackError && nextProps.onPlaybackError(err);\n          });\n        }\n      });\n\n      this.videoRef = React.createRef();\n      this.state = {\n        videoElementEventHandlers: {},\n        render: _renderers.renderWithoutSource\n      };\n    }\n\n    componentDidMount() {\n      const videoElement = this.videoRef.current;\n\n      if (videoElement) {\n        resolveImplementation(this, this.props.configuration, videoElement, this.handleTrackElementDataChange).then(implementation => {\n          this.implementation = implementation;\n          const render = implementation.render,\n                videoElementEventHandlers = implementation.videoElementEventHandlers,\n                thirdPartyPlayer = implementation.thirdPartyPlayer;\n          this.setState({\n            render,\n            videoElementEventHandlers\n          });\n\n          if (this.props.onReady) {\n            this.props.onReady({\n              setProperties: this.setProperties,\n              thirdPartyPlayer\n            });\n          }\n\n          if (this.props.source) {\n            return this.handleSourceChange(this.props);\n          }\n        }).catch(err => {\n          if (this.props.onPlaybackError && err instanceof _types.PlaybackError) {\n            this.props.onPlaybackError(err);\n          } else {\n            throw err;\n          }\n        });\n      }\n    }\n\n    componentWillUnmount() {\n      const videoElement = this.videoRef.current;\n\n      if (videoElement) {\n        // $FlowFixMe\n        if (videoElement === document.pictureInPictureElement) {\n          // $FlowFixMe\n          return document.exitPictureInPicture(); // $FlowFixMe\n        } else if ( // $FlowFixMe\n        videoElement.webkitPresentationMode === 'picture-in-picture' && // $FlowFixMe\n        typeof videoElement.webkitSetPresentationMode === 'function') {\n          // $FlowFixMe\n          videoElement.webkitSetPresentationMode('inline');\n        }\n      }\n\n      if (this.implementation && this.implementation.cleanup) {\n        return this.implementation.cleanup().catch(err => {\n          throw err;\n        });\n      }\n    }\n\n    getSnapshotBeforeUpdate() {\n      const previousVideoElement = this.videoRef.current; // $FlowFixMe: Type defs not up-to-date.\n\n      const pipElement = document.pictureInPictureElement; // $FlowFixMe\n\n      const presentationMode = previousVideoElement.webkitPresentationMode;\n      const wasPipActive = previousVideoElement === pipElement || presentationMode === 'picture-in-picture'; // $FlowFixMe\n\n      return {\n        wasPipActive,\n        previousVideoElement: this.videoRef.current\n      };\n    }\n\n    componentDidUpdate(prevProps, prevState, snapshot) {\n      const implementation = this.implementation;\n\n      if (implementation) {\n        if (prevProps.source !== this.props.source) {\n          if (snapshot && snapshot.wasPipActive) {\n            // $FlowFixMe\n            if (document.exitPictureInPicture) {\n              document.exitPictureInPicture().then(() => this.handleSourceChange(this.props, prevProps), () => this.handleSourceChange(this.props, prevProps));\n            } else if (snapshot.previousVideoElement && // $FlowFixMe\n            typeof snapshot.previousVideoElement.webkitSetPresentationMode === 'function') {\n              snapshot.previousVideoElement.webkitSetPresentationMode('inline');\n              this.handleSourceChange(this.props, prevProps);\n            }\n          } else {\n            this.handleSourceChange(this.props, prevProps);\n          }\n        } else if (prevProps.textTracks !== this.props.textTracks) {\n          implementation.textTrackManager.handleTextTracksPropChange(this.props);\n        }\n      }\n    }\n\n    render() {\n      const videoRef = this.videoRef;\n      const _this$state = this.state,\n            videoElementEventHandlers = _this$state.videoElementEventHandlers,\n            render = _this$state.render,\n            trackElementData = _this$state.trackElementData;\n      const playsInline = !this.props.configuration || this.props.configuration.playsInline == null || this.props.configuration.playsInline;\n      return render(videoRef, videoElementEventHandlers, this.props, baseClassName, playsInline, trackElementData);\n    }\n\n  }\n\n  _defineProperty(VideoStreamer, \"defaultProps\", {\n    classNamePrefix: _common.defaultClassNamePrefix\n  });\n\n  VideoStreamer.displayName = name;\n  return VideoStreamer;\n}\n\nvar _default = createVideoStreamerComponent;\nexports.default = _default;","map":{"version":3,"sources":["../../../../src/replay/components/player/VideoStreamer/common/createVideoStreamerComponent.js"],"names":["baseClassName","React","classNamePrefix","defaultClassNamePrefix","constructor","videoElementEventHandlers","render","renderWithoutSource","playbackProps","applyProperties","trackElementData","implementation","err","nextProps","componentDidMount","videoElement","resolveImplementation","thirdPartyPlayer","setProperties","PlaybackError","componentWillUnmount","document","getSnapshotBeforeUpdate","previousVideoElement","pipElement","presentationMode","wasPipActive","current","componentDidUpdate","prevProps","snapshot","videoRef","playsInline","VideoStreamer","createVideoStreamerComponent"],"mappings":"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","sourcesContent":["// @flow\nimport * as React from 'react';\nimport { defaultClassNamePrefix } from '../../../common';\nimport type { PlaybackProps, VideoStreamerConfiguration, VideoStreamerImplProps } from '../types';\nimport type {\n  SimplifiedVideoStreamer,\n  StreamerImplementationParts,\n  TrackElementData,\n  VideoStreamerRenderer\n} from './types';\nimport { renderWithoutSource } from './renderers';\nimport { PlaybackError } from '../types';\n\nconst baseClassName = 'video-streamer';\n\ntype ResolveImplementation<C: VideoStreamerConfiguration, P: VideoStreamerImplProps<C>, T> = (\n  component: SimplifiedVideoStreamer<C, P>,\n  configuration: ?C,\n  videoElement: HTMLVideoElement,\n  onTrackElementDataChange: (?Array<TrackElementData>) => void\n) => Promise<StreamerImplementationParts<C, P, T>>;\n\ntype State = {\n  videoElementEventHandlers: { [string]: (any) => void },\n  trackElementData?: ?Array<TrackElementData>,\n  render: VideoStreamerRenderer\n};\n\nfunction createVideoStreamerComponent<C: VideoStreamerConfiguration, P: VideoStreamerImplProps<C>, T>(\n  name: string,\n  resolveImplementation: ResolveImplementation<C, P, T>\n) {\n  class VideoStreamer extends React.Component<P, State> {\n    static defaultProps = {\n      classNamePrefix: defaultClassNamePrefix\n    };\n\n    constructor(props: P) {\n      super(props);\n      this.videoRef = React.createRef();\n      this.state = {\n        videoElementEventHandlers: {},\n        render: renderWithoutSource\n      };\n    }\n\n    implementation: ?StreamerImplementationParts<C, P, T>;\n    videoRef: { current: null | HTMLVideoElement };\n\n    setProperties = (playbackProps: PlaybackProps) => {\n      const applyProperties = this.implementation && this.implementation.applyProperties;\n      if (applyProperties) {\n        applyProperties(playbackProps);\n      }\n    };\n\n    handleTrackElementDataChange = (trackElementData: ?Array<TrackElementData>) => {\n      this.setState({ trackElementData });\n    };\n\n    handleSourceChange = (nextProps: P, prevProps?: P) => {\n      const implementation = this.implementation;\n      if (implementation) {\n        implementation.startPlaybackSession();\n        implementation.textTrackManager.clear();\n        return implementation\n          .handleSourceChange(nextProps, prevProps)\n          .then(() => {\n            implementation.audioTrackManager.handleSourceChange();\n            implementation.textTrackManager.handleSourcePropChange(nextProps);\n          })\n          .catch(err => {\n            implementation.endPlaybackSession('dead');\n            return nextProps.onPlaybackError && nextProps.onPlaybackError(err);\n          });\n      }\n    };\n\n    componentDidMount() {\n      const videoElement = this.videoRef.current;\n      if (videoElement) {\n        resolveImplementation(this, this.props.configuration, videoElement, this.handleTrackElementDataChange)\n          .then(implementation => {\n            this.implementation = implementation;\n            const { render, videoElementEventHandlers, thirdPartyPlayer } = implementation;\n            this.setState({\n              render,\n              videoElementEventHandlers\n            });\n            if (this.props.onReady) {\n              this.props.onReady({ setProperties: this.setProperties, thirdPartyPlayer });\n            }\n            if (this.props.source) {\n              return this.handleSourceChange(this.props);\n            }\n          })\n          .catch(err => {\n            if (this.props.onPlaybackError && err instanceof PlaybackError) {\n              this.props.onPlaybackError(err);\n            } else {\n              throw err;\n            }\n          });\n      }\n    }\n\n    componentWillUnmount() {\n      const videoElement = this.videoRef.current;\n      if (videoElement) {\n        // $FlowFixMe\n        if (videoElement === document.pictureInPictureElement) {\n          // $FlowFixMe\n          return document.exitPictureInPicture();\n          // $FlowFixMe\n        } else if (\n          // $FlowFixMe\n          videoElement.webkitPresentationMode === 'picture-in-picture' && // $FlowFixMe\n          typeof videoElement.webkitSetPresentationMode === 'function'\n        ) {\n          // $FlowFixMe\n          videoElement.webkitSetPresentationMode('inline');\n        }\n      }\n      if (this.implementation && this.implementation.cleanup) {\n        return this.implementation.cleanup().catch(err => {\n          throw err;\n        });\n      }\n    }\n\n    getSnapshotBeforeUpdate() {\n      const previousVideoElement = this.videoRef.current;\n      // $FlowFixMe: Type defs not up-to-date.\n      const pipElement = document.pictureInPictureElement;\n      // $FlowFixMe\n      const presentationMode = previousVideoElement.webkitPresentationMode;\n      const wasPipActive = previousVideoElement === pipElement || presentationMode === 'picture-in-picture'; // $FlowFixMe\n      return {\n        wasPipActive,\n        previousVideoElement: this.videoRef.current\n      };\n    }\n\n    componentDidUpdate(\n      prevProps: P,\n      prevState: State,\n      snapshot?: { wasPipActive: boolean, previousVideoElement: HTMLVideoElement }\n    ) {\n      const implementation = this.implementation;\n      if (implementation) {\n        if (prevProps.source !== this.props.source) {\n          if (snapshot && snapshot.wasPipActive) {\n            // $FlowFixMe\n            if (document.exitPictureInPicture) {\n              document.exitPictureInPicture().then(\n                () => this.handleSourceChange(this.props, prevProps),\n                () => this.handleSourceChange(this.props, prevProps)\n              );\n            } else if (\n              snapshot.previousVideoElement &&\n              // $FlowFixMe\n              typeof snapshot.previousVideoElement.webkitSetPresentationMode === 'function'\n            ) {\n              snapshot.previousVideoElement.webkitSetPresentationMode('inline');\n              this.handleSourceChange(this.props, prevProps);\n            }\n          } else {\n            this.handleSourceChange(this.props, prevProps);\n          }\n        } else if (prevProps.textTracks !== this.props.textTracks) {\n          implementation.textTrackManager.handleTextTracksPropChange(this.props);\n        }\n      }\n    }\n\n    render() {\n      const { videoRef } = this;\n      const { videoElementEventHandlers, render, trackElementData } = this.state;\n      const playsInline =\n        !this.props.configuration ||\n        this.props.configuration.playsInline == null ||\n        this.props.configuration.playsInline;\n      return render(videoRef, videoElementEventHandlers, this.props, baseClassName, playsInline, trackElementData);\n    }\n  }\n\n  VideoStreamer.displayName = name;\n  return VideoStreamer;\n}\n\nexport default createVideoStreamerComponent;\n"]},"metadata":{},"sourceType":"script"}