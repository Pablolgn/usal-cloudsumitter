{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _playbackLifeCycleManager = require(\"../common/playbackLifeCycleManager\");\n\nvar _common = require(\"../../../common\");\n\nvar _sourceNormalizer = _interopRequireDefault(require(\"../common/sourceNormalizer\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*export type TextTracksStateProps = {\n  currentTextTrack?: ?AvailableTrack,\n  textTracks?: Array<AvailableTrack>\n};*/\n\n\nconst trackModeMappings = ['disabled', 'hidden', 'showing']; // Index corresponds with \"enum\" value.\n\nfunction getTrackMode(textTrack) {\n  const mode = textTrack.mode;\n  return typeof mode === 'number' ? trackModeMappings[mode] : mode;\n}\n\nfunction setTrackMode(textTrack, newMode) {\n  // $FlowFixMe Some browsers use numbers mapping to modes.\n  textTrack.mode = typeof textTrack.mode === 'number' ? trackModeMappings.indexOf(newMode) : newMode;\n}\n\nfunction isEqual(a, b) {\n  return Number.isNaN(a) && Number.isNaN(b) || a == null && b == null || a === b;\n}\n\nfunction isVideoElementTrackValid(textTrack) {\n  // Detecting empty dummy tracks originating from HLS streams in Safari.\n  return textTrack.kind !== 'metadata' && !('inBandMetadataTrackDispatchType' in textTrack) || textTrack.cues && textTrack.cues.length || textTrack.label || textTrack.language;\n}\n\nfunction isSourceTracksEqual(a, b) {\n  if (a && b) {\n    if (a.cues && b.cues) {\n      const ac = a.cues,\n            bc = b.cues;\n\n      if (ac.length === bc.length) {\n        const isCuesDifferent = ac.filter((cue, index) => cue.start === bc[index].start && cue.end === bc[index].end && cue.content === bc[index].content).length !== ac.length;\n\n        if (isCuesDifferent) {\n          return false;\n        }\n      }\n    }\n\n    return isEqual(a.language, b.language) && isEqual(a.kind, b.kind) && isEqual(a.label, b.label) && isEqual(a.src, b.src);\n  } else {\n    return isEqual(a, b);\n  }\n}\n\nfunction createSelectableTrack(id, origin, videoElementTrack) {\n  return {\n    id,\n    kind: videoElementTrack.kind || '',\n    label: videoElementTrack.label || '',\n    language: videoElementTrack.language || '',\n    origin\n  };\n}\n\nconst getTextTrackManager = (videoElement, update, updateTrackElementData) => {\n  // Should use TextTracksStateProps above.\n  let managedTracks = [];\n  let currentTextTrack = null;\n  let selectableTextTracks = _playbackLifeCycleManager.emptyTracks;\n  let unique = 0;\n  const Cue = window.VTTCue || window.TextTrackCue;\n\n  function notifyPropertyChanges() {\n    currentTextTrack = managedTracks.filter(m => m.videoElementTrack != null && getTrackMode(m.videoElementTrack) === 'showing').map(m => m.selectableTrack)[0];\n    const textTracks = managedTracks.filter(m => m.selectableTrack).map(m => m.selectableTrack);\n\n    if ((0, _common.isShallowEqual)(textTracks, selectableTextTracks)) {\n      // $FlowFixMe Complaints about null entries, despite filter above.\n      update({\n        currentTextTrack,\n        textTracks: selectableTextTracks\n      });\n    } else {\n      selectableTextTracks = textTracks;\n      update({\n        currentTextTrack,\n        textTracks\n      });\n    }\n  }\n\n  function addTracks(sourceTracks) {\n    if (Array.isArray(sourceTracks)) {\n      videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n      videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n      const freshSourceTracks = sourceTracks.filter(sourceTrack => {\n        const managedTrackMatches = managedTracks.filter(managedTrack => {\n          return isSourceTracksEqual(managedTrack.sourceTrack, sourceTrack) && !managedTrack.isBlacklisted;\n        });\n\n        if (managedTrackMatches.length === 0) {\n          return true;\n        } else {\n          const alreadyAddedTrack = managedTrackMatches[0];\n          alreadyAddedTrack.sourceTrack = sourceTrack;\n          alreadyAddedTrack.isBlacklisted = false;\n          alreadyAddedTrack.isLoaded = true; // Is this assumption correct?\n\n          return false;\n        }\n      });\n      const freshManagedTracks = freshSourceTracks.map(sourceTrack => {\n        const id = ++unique;\n\n        if (Array.isArray(sourceTrack.cues)) {\n          const cues = sourceTrack.cues;\n          const videoElementTrack = videoElement.addTextTrack(sourceTrack.kind || 'subtitles', sourceTrack.label, sourceTrack.language);\n          cues.forEach(cue => {\n            videoElementTrack.addCue(new Cue(cue.start, cue.end, cue.content));\n          });\n          return {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack,\n            selectableTrack: createSelectableTrack(id, 'side-loaded', videoElementTrack),\n            loadPromise: Promise.resolve(videoElementTrack),\n            isLoaded: true\n          };\n        } else {\n          const trackElementData = {\n            src: sourceTrack.src,\n            srclang: sourceTrack.language,\n            kind: sourceTrack.kind || 'subtitles',\n            label: sourceTrack.label\n          };\n          const loadPromise = new Promise(resolve => {\n            trackElementData.onRef = trackElement => {\n              const t = trackElement;\n\n              if (t) {\n                setTrackMode(t.track, 'hidden');\n\n                const handleLoad = () => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve(t.track);\n                };\n\n                const handleError = e => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve();\n                };\n\n                t.addEventListener('load', handleLoad);\n                t.addEventListener('error', handleError);\n              }\n            };\n          });\n          const managedTrack = {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack: undefined,\n            selectableTrack: undefined,\n            trackElementData,\n            loadPromise,\n            isLoaded: false\n          };\n          loadPromise.then(videoElementTrack => {\n            if (videoElementTrack != null) {\n              managedTrack.videoElementTrack = videoElementTrack;\n              managedTrack.selectableTrack = createSelectableTrack(id, 'side-loaded', videoElementTrack);\n            }\n\n            managedTrack.isLoaded = true;\n          });\n          return managedTrack;\n        }\n      });\n      managedTracks = managedTracks.concat(freshManagedTracks);\n      updateTrackElementData( // $FlowFixMe Filtering away null/undefined isn't recognised.\n      managedTracks.filter(t => t.trackElementData && !t.isBlacklisted).map(t => t.trackElementData));\n      return Promise.all(freshManagedTracks.map(managedTrack => managedTrack.loadPromise)).then(() => {\n        videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n        videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n        notifyPropertyChanges();\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function updateFromVideoElement(textTracksList) {\n    if (textTracksList.length === 0 && managedTracks.length === 0) {\n      return;\n    }\n\n    const videoElementTracks = [];\n\n    for (let i = 0; i < textTracksList.length; i++) {\n      // Awkward for-loop because Flow doesn't understand Array.from().\n      videoElementTracks.push(textTracksList[i]);\n    }\n\n    const cleanedUpManagedTracks = managedTracks.filter(managedTrack => {\n      return videoElementTracks.indexOf(managedTrack.videoElementTrack) >= 0;\n    }); //const isRemoving = cleanedUpManagedTracks.length < managedTracks.length;\n    //const isAdding = videoElementTracks.length > cleanedUpManagedTracks.length;\n\n    if (videoElementTracks.length > cleanedUpManagedTracks.length) {\n      const freshVideoElementTracks = videoElementTracks.filter(videoElementTrack => isVideoElementTrackValid(videoElementTrack) && cleanedUpManagedTracks.filter(function (managedTrack) {\n        return videoElementTrack === managedTrack.videoElementTrack;\n      }).length === 0);\n      const freshManagedTracks = freshVideoElementTracks.map(videoElementTrack => {\n        const id = ++unique;\n        return {\n          id,\n          sourceTrack: null,\n          videoElementTrack,\n          isBlacklisted: false,\n          selectableTrack: createSelectableTrack(id, 'in-stream', videoElementTrack),\n          isLoaded: true\n        };\n      });\n      managedTracks = cleanedUpManagedTracks.concat(freshManagedTracks);\n    } else {\n      managedTracks = cleanedUpManagedTracks;\n    }\n  }\n\n  function cleanupTracks(isNewSession) {\n    updateFromVideoElement(videoElement.textTracks);\n    managedTracks.forEach(m => {\n      // Blacklisting and removing side-loaded tracks.\n      if (isNewSession || m.sourceTrack != null) {\n        m.isBlacklisted = true;\n      }\n\n      if (m.videoElementTrack != null && isNewSession) {\n        const vt = m.videoElementTrack;\n\n        if (vt.cues) {\n          while (vt.cues.length) {\n            vt.removeCue(vt.cues[0]);\n          }\n        }\n\n        setTrackMode(vt, 'disabled');\n      }\n\n      m.selectableTrack = null;\n    });\n    selectableTextTracks = _playbackLifeCycleManager.emptyTracks;\n    updateTrackElementData([]);\n  }\n\n  function handleSourcePropChange(newProps) {\n    updateFromVideoElement(videoElement.textTracks);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    const source = (0, _sourceNormalizer.default)(newProps.source);\n\n    if (source && source.textTracks) {\n      addTracks(newTracks.concat(source.textTracks));\n    } else {\n      addTracks(newTracks);\n    }\n  }\n\n  function handleTextTracksPropChange(newProps) {\n    cleanupTracks(false);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    addTracks(newTracks);\n  }\n\n  function clear() {\n    cleanupTracks(true);\n  }\n\n  function handleSelectedTextTrackChange(selectedTextTrack) {\n    managedTracks.filter(mt => mt.videoElementTrack && getTrackMode(mt.videoElementTrack) === 'showing').forEach(mt => mt.videoElementTrack && setTrackMode(mt.videoElementTrack, 'hidden'));\n\n    if (selectedTextTrack) {\n      const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedTextTrack)[0];\n\n      if (managedTrack && managedTrack.videoElementTrack) {\n        setTrackMode(managedTrack.videoElementTrack, 'showing');\n      }\n    }\n\n    notifyPropertyChanges();\n  }\n\n  function handleTrackAdd() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function handleTrackRemove() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function cleanup() {\n    videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n  }\n\n  function initialize() {\n    videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n  }\n\n  initialize();\n  return {\n    handleSelectedTextTrackChange,\n    handleTextTracksPropChange,\n    handleSourcePropChange,\n    clear,\n    cleanup\n  };\n};\n\nvar _default = getTextTrackManager;\nexports.default = _default;","map":{"version":3,"sources":["../../../../src/replay/components/player/VideoStreamer/BasicVideoStreamer/textTrackManager.js"],"names":["trackModeMappings","mode","textTrack","Number","a","b","ac","bc","isCuesDifferent","cue","isEqual","kind","videoElementTrack","label","language","origin","getTextTrackManager","managedTracks","currentTextTrack","selectableTextTracks","emptyTracks","unique","Cue","window","m","getTrackMode","textTracks","update","Array","videoElement","freshSourceTracks","sourceTrack","managedTrackMatches","managedTrack","isSourceTracksEqual","alreadyAddedTrack","freshManagedTracks","id","cues","isBlacklisted","selectableTrack","createSelectableTrack","loadPromise","Promise","isLoaded","trackElementData","src","srclang","resolve","trackElement","t","setTrackMode","handleLoad","handleError","e","updateTrackElementData","notifyPropertyChanges","textTracksList","videoElementTracks","i","cleanedUpManagedTracks","freshVideoElementTracks","isVideoElementTrackValid","updateFromVideoElement","isNewSession","vt","newTracks","newProps","source","addTracks","cleanupTracks","mt","initialize","cleanup"],"mappings":"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","sourcesContent":["// @flow\n\nimport type { AvailableTrack, PlaybackSource, SourceTrack, VideoStreamState } from '../types';\nimport { emptyTracks } from '../common/playbackLifeCycleManager';\nimport { isShallowEqual } from '../../../common';\nimport type { TextTrackManager, TrackElementData } from '../common/types';\nimport normalizeSource from '../common/sourceNormalizer';\n\nexport type ManagedTextTrack = {\n  isBlacklisted: boolean,\n  sourceTrack: ?SourceTrack,\n  videoElementTrack?: ?TextTrack,\n  selectableTrack: ?AvailableTrack,\n  trackElementData?: ?TrackElementData,\n  loadPromise?: Promise<?TextTrack>,\n  isLoaded: boolean,\n  error?: any\n};\n\ntype HTMLTextTrackMode = 'disabled' | 'hidden' | 'showing';\n\n/*export type TextTracksStateProps = {\n  currentTextTrack?: ?AvailableTrack,\n  textTracks?: Array<AvailableTrack>\n};*/\n\nconst trackModeMappings = ['disabled', 'hidden', 'showing']; // Index corresponds with \"enum\" value.\n\nfunction getTrackMode(textTrack: TextTrack) {\n  const mode = textTrack.mode;\n  return typeof mode === 'number' ? trackModeMappings[mode] : mode;\n}\n\nfunction setTrackMode(textTrack: TextTrack, newMode: HTMLTextTrackMode) {\n  // $FlowFixMe Some browsers use numbers mapping to modes.\n  textTrack.mode = typeof textTrack.mode === 'number' ? trackModeMappings.indexOf(newMode) : newMode;\n}\n\nfunction isEqual(a: any, b: any): boolean {\n  return (Number.isNaN(a) && Number.isNaN(b)) || (a == null && b == null) || a === b;\n}\n\nfunction isVideoElementTrackValid(textTrack: TextTrack) {\n  // Detecting empty dummy tracks originating from HLS streams in Safari.\n  return (\n    (textTrack.kind !== 'metadata' && !('inBandMetadataTrackDispatchType' in textTrack)) ||\n    (textTrack.cues && textTrack.cues.length) ||\n    textTrack.label ||\n    textTrack.language\n  );\n}\n\nfunction isSourceTracksEqual(a: ?SourceTrack, b: ?SourceTrack): boolean {\n  if (a && b) {\n    if (a.cues && b.cues) {\n      const ac = a.cues,\n        bc = b.cues;\n      if (ac.length === bc.length) {\n        const isCuesDifferent =\n          ac.filter(\n            (cue, index) =>\n              cue.start === bc[index].start && cue.end === bc[index].end && cue.content === bc[index].content\n          ).length !== ac.length;\n        if (isCuesDifferent) {\n          return false;\n        }\n      }\n    }\n    return (\n      isEqual(a.language, b.language) && isEqual(a.kind, b.kind) && isEqual(a.label, b.label) && isEqual(a.src, b.src)\n    );\n  } else {\n    return isEqual(a, b);\n  }\n}\n\nfunction createSelectableTrack(\n  id: number,\n  origin: 'in-stream' | 'side-loaded',\n  videoElementTrack: TextTrack\n): AvailableTrack {\n  return {\n    id,\n    kind: videoElementTrack.kind || '',\n    label: videoElementTrack.label || '',\n    language: videoElementTrack.language || '',\n    origin\n  };\n}\n\nconst getTextTrackManager = (\n  videoElement: HTMLVideoElement,\n  update: <T: VideoStreamState>(props: T) => void,\n  updateTrackElementData: (Array<TrackElementData>) => void\n): TextTrackManager => {\n  // Should use TextTracksStateProps above.\n  let managedTracks: Array<ManagedTextTrack> = [];\n  let currentTextTrack = null;\n  let selectableTextTracks = emptyTracks;\n  let unique = 0;\n  const Cue = window.VTTCue || window.TextTrackCue;\n\n  function notifyPropertyChanges() {\n    currentTextTrack = managedTracks\n      .filter(m => m.videoElementTrack != null && getTrackMode(m.videoElementTrack) === 'showing')\n      .map(m => m.selectableTrack)[0];\n\n    const textTracks = managedTracks.filter(m => m.selectableTrack).map(m => m.selectableTrack);\n    if (isShallowEqual(textTracks, selectableTextTracks)) {\n      // $FlowFixMe Complaints about null entries, despite filter above.\n      update({\n        currentTextTrack,\n        textTracks: selectableTextTracks\n      });\n    } else {\n      selectableTextTracks = textTracks;\n      update({\n        currentTextTrack,\n        textTracks\n      });\n    }\n  }\n\n  function addTracks(sourceTracks?: Array<SourceTrack>) {\n    if (Array.isArray(sourceTracks)) {\n      videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n      videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n\n      const freshSourceTracks = sourceTracks.filter(sourceTrack => {\n        const managedTrackMatches = managedTracks.filter(managedTrack => {\n          return isSourceTracksEqual(managedTrack.sourceTrack, sourceTrack) && !managedTrack.isBlacklisted;\n        });\n        if (managedTrackMatches.length === 0) {\n          return true;\n        } else {\n          const alreadyAddedTrack = managedTrackMatches[0];\n          alreadyAddedTrack.sourceTrack = sourceTrack;\n          alreadyAddedTrack.isBlacklisted = false;\n          alreadyAddedTrack.isLoaded = true; // Is this assumption correct?\n          return false;\n        }\n      });\n\n      const freshManagedTracks: Array<ManagedTextTrack> = freshSourceTracks.map(sourceTrack => {\n        const id = ++unique;\n        if (Array.isArray(sourceTrack.cues)) {\n          const cues = sourceTrack.cues;\n          const videoElementTrack = videoElement.addTextTrack(\n            sourceTrack.kind || 'subtitles',\n            sourceTrack.label,\n            sourceTrack.language\n          );\n          cues.forEach(cue => {\n            videoElementTrack.addCue(new Cue(cue.start, cue.end, cue.content));\n          });\n          return {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack,\n            selectableTrack: createSelectableTrack(id, 'side-loaded', videoElementTrack),\n            loadPromise: Promise.resolve(videoElementTrack),\n            isLoaded: true\n          };\n        } else {\n          const trackElementData: TrackElementData = {\n            src: sourceTrack.src,\n            srclang: sourceTrack.language,\n            kind: sourceTrack.kind || 'subtitles',\n            label: sourceTrack.label\n          };\n          const loadPromise = new Promise(resolve => {\n            trackElementData.onRef = (trackElement: ?HTMLTrackElement) => {\n              const t = trackElement;\n              if (t) {\n                setTrackMode(t.track, 'hidden');\n                const handleLoad = () => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve(t.track);\n                };\n                const handleError = (e: Event) => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve();\n                };\n                t.addEventListener('load', handleLoad);\n                t.addEventListener('error', handleError);\n              }\n            };\n          });\n          const managedTrack = {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack: undefined,\n            selectableTrack: undefined,\n            trackElementData,\n            loadPromise,\n            isLoaded: false\n          };\n          loadPromise.then(videoElementTrack => {\n            if (videoElementTrack != null) {\n              managedTrack.videoElementTrack = videoElementTrack;\n              managedTrack.selectableTrack = createSelectableTrack(id, 'side-loaded', videoElementTrack);\n            }\n            managedTrack.isLoaded = true;\n          });\n          return managedTrack;\n        }\n      });\n\n      managedTracks = managedTracks.concat(freshManagedTracks);\n\n      updateTrackElementData(\n        // $FlowFixMe Filtering away null/undefined isn't recognised.\n        managedTracks.filter(t => t.trackElementData && !t.isBlacklisted).map(t => t.trackElementData)\n      );\n\n      return Promise.all(freshManagedTracks.map(managedTrack => managedTrack.loadPromise)).then(() => {\n        videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n        videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n        notifyPropertyChanges();\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function updateFromVideoElement(textTracksList: TextTrackList) {\n    if (textTracksList.length === 0 && managedTracks.length === 0) {\n      return;\n    }\n\n    const videoElementTracks: Array<TextTrack> = [];\n    for (let i = 0; i < textTracksList.length; i++) {\n      // Awkward for-loop because Flow doesn't understand Array.from().\n      videoElementTracks.push(textTracksList[i]);\n    }\n\n    const cleanedUpManagedTracks = managedTracks.filter(managedTrack => {\n      return videoElementTracks.indexOf(managedTrack.videoElementTrack) >= 0;\n    });\n\n    //const isRemoving = cleanedUpManagedTracks.length < managedTracks.length;\n    //const isAdding = videoElementTracks.length > cleanedUpManagedTracks.length;\n\n    if (videoElementTracks.length > cleanedUpManagedTracks.length) {\n      const freshVideoElementTracks = videoElementTracks.filter(\n        videoElementTrack =>\n          isVideoElementTrackValid(videoElementTrack) &&\n          cleanedUpManagedTracks.filter(function(managedTrack) {\n            return videoElementTrack === managedTrack.videoElementTrack;\n          }).length === 0\n      );\n      const freshManagedTracks: Array<ManagedTextTrack> = freshVideoElementTracks.map(videoElementTrack => {\n        const id = ++unique;\n        return {\n          id,\n          sourceTrack: null,\n          videoElementTrack,\n          isBlacklisted: false,\n          selectableTrack: createSelectableTrack(id, 'in-stream', videoElementTrack),\n          isLoaded: true\n        };\n      });\n      managedTracks = cleanedUpManagedTracks.concat(freshManagedTracks);\n    } else {\n      managedTracks = cleanedUpManagedTracks;\n    }\n  }\n\n  function cleanupTracks(isNewSession: boolean) {\n    updateFromVideoElement(videoElement.textTracks);\n    managedTracks.forEach(m => {\n      // Blacklisting and removing side-loaded tracks.\n      if (isNewSession || m.sourceTrack != null) {\n        m.isBlacklisted = true;\n      }\n      if (m.videoElementTrack != null && isNewSession) {\n        const vt = m.videoElementTrack;\n        if (vt.cues) {\n          while (vt.cues.length) {\n            vt.removeCue(vt.cues[0]);\n          }\n        }\n        setTrackMode(vt, 'disabled');\n      }\n      m.selectableTrack = null;\n    });\n    selectableTextTracks = emptyTracks;\n    updateTrackElementData([]);\n  }\n\n  function handleSourcePropChange(newProps: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    updateFromVideoElement(videoElement.textTracks);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    const source = normalizeSource(newProps.source);\n    if (source && source.textTracks) {\n      addTracks(newTracks.concat(source.textTracks));\n    } else {\n      addTracks(newTracks);\n    }\n  }\n\n  function handleTextTracksPropChange(newProps: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    cleanupTracks(false);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    addTracks(newTracks);\n  }\n\n  function clear() {\n    cleanupTracks(true);\n  }\n\n  function handleSelectedTextTrackChange(selectedTextTrack: ?AvailableTrack) {\n    managedTracks\n      .filter(mt => mt.videoElementTrack && getTrackMode(mt.videoElementTrack) === 'showing')\n      .forEach(mt => mt.videoElementTrack && setTrackMode(mt.videoElementTrack, 'hidden'));\n    if (selectedTextTrack) {\n      const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedTextTrack)[0];\n      if (managedTrack && managedTrack.videoElementTrack) {\n        setTrackMode(managedTrack.videoElementTrack, 'showing');\n      }\n    }\n    notifyPropertyChanges();\n  }\n\n  function handleTrackAdd() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function handleTrackRemove() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function cleanup() {\n    videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n  }\n\n  function initialize() {\n    videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n  }\n\n  initialize();\n\n  return {\n    handleSelectedTextTrackChange,\n    handleTextTracksPropChange,\n    handleSourcePropChange,\n    clear,\n    cleanup\n  };\n};\n\nexport default getTextTrackManager;\n"]},"metadata":{},"sourceType":"script"}