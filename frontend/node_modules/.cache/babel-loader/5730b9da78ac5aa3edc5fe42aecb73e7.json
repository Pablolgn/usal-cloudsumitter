{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.getPreferredSettingsApplicator = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _connectControl = _interopRequireDefault(require(\"../PlayerController/connectControl\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst noop = () => {};\n\nconst getTrackFromLanguageAndKind = (language, kind, tracks, ignorableLength) => {\n  if (Array.isArray(tracks) && tracks.length > ignorableLength) {\n    return tracks.filter(track => track.language === language && track.kind === kind)[0] || tracks.filter(track => track.language === language)[0] || tracks.filter(track => track.kind === kind)[0];\n  }\n};\n\nconst getTrackToSelect = (preferredLanguage, preferredKind, prevTracks, nextTracks, ignorableTrackListLength) => {\n  if (prevTracks !== nextTracks && Array.isArray(nextTracks) && nextTracks.length > 0) {\n    return getTrackFromLanguageAndKind(preferredLanguage, preferredKind, nextTracks, ignorableTrackListLength);\n  }\n};\n\nconst mergePreferredSettings = (configuration, programmaticSettings, localStorage, sessionStorage) => {\n  const userSettingsConfig = configuration && configuration.userSettings;\n  const storageKey = userSettingsConfig && userSettingsConfig.storageKey;\n\n  if (userSettingsConfig && storageKey) {\n    let localSettings = {};\n    let sessionSettings = {};\n\n    try {\n      sessionSettings = JSON.parse(sessionStorage.getItem(storageKey) || '{}');\n    } catch (e) {}\n\n    try {\n      localSettings = JSON.parse(localStorage.getItem(storageKey) || '{}');\n    } catch (e) {}\n\n    if (userSettingsConfig.hasPrecedence) {\n      return _objectSpread({}, programmaticSettings, {}, localSettings, {}, sessionSettings);\n    } else {\n      return _objectSpread({}, localSettings, {}, sessionSettings, {}, programmaticSettings);\n    }\n  } else {\n    return programmaticSettings;\n  }\n};\n\nconst getPropsToBeUpdated = (prevPlayState, nextPlayState, prevAudioTracks, prevTextTracks, nextAudioTracks, nextTextTracks, preferredSettings) => {\n  const updates = {};\n\n  if (nextPlayState !== prevPlayState && nextPlayState === 'starting') {\n    if (preferredSettings.volume != null) {\n      updates.volume = preferredSettings.volume;\n    }\n\n    if (preferredSettings.isMuted != null) {\n      updates.isMuted = preferredSettings.isMuted;\n    }\n  }\n\n  const audioTrackToSelect = getTrackToSelect(preferredSettings.audioTrackLanguage, preferredSettings.audioTrackKind, prevAudioTracks, nextAudioTracks, 1);\n\n  if (audioTrackToSelect) {\n    updates.selectedAudioTrack = audioTrackToSelect;\n  }\n\n  const textTrackToSelect = getTrackToSelect(preferredSettings.textTrackLanguage, preferredSettings.textTrackKind, prevTextTracks, nextTextTracks, 0);\n\n  if (textTrackToSelect) {\n    updates.selectedTextTrack = textTrackToSelect;\n  }\n\n  return updates;\n};\n\nconst onPropsChanged = (prevProps, nextProps, localStorage, sessionStorage) => {\n  const configuration = nextProps.configuration,\n        playState = nextProps.playState,\n        audioTracks = nextProps.audioTracks,\n        textTracks = nextProps.textTracks,\n        volume = nextProps.volume,\n        isMuted = nextProps.isMuted,\n        textTrackLanguage = nextProps.textTrackLanguage,\n        textTrackKind = nextProps.textTrackKind,\n        audioTrackLanguage = nextProps.audioTrackLanguage,\n        audioTrackKind = nextProps.audioTrackKind,\n        setProperties = nextProps.setProperties;\n  const programmaticSettings = {};\n\n  if (volume != null) {\n    programmaticSettings.volume = volume;\n  }\n\n  if (isMuted != null) {\n    programmaticSettings.isMuted = isMuted;\n  }\n\n  if (textTrackLanguage != null) {\n    programmaticSettings.textTrackLanguage = textTrackLanguage;\n  }\n\n  if (textTrackKind != null) {\n    programmaticSettings.textTrackKind = textTrackKind;\n  }\n\n  if (audioTrackLanguage != null) {\n    programmaticSettings.audioTrackLanguage = audioTrackLanguage;\n  }\n\n  if (audioTrackKind != null) {\n    programmaticSettings.audioTrackKind = audioTrackKind;\n  }\n\n  const mergedSettings = mergePreferredSettings(configuration, programmaticSettings, localStorage, sessionStorage);\n  const propsToBeUpdated = getPropsToBeUpdated(prevProps.playState, playState, prevProps.audioTracks, prevProps.textTracks, audioTracks, textTracks, mergedSettings);\n\n  if (Object.keys(propsToBeUpdated).length > 0) {\n    setProperties(propsToBeUpdated);\n  }\n}; // Testable version:\n\n\nconst getPreferredSettingsApplicator = (localStorage = window.localStorage, sessionStorage = window.sessionStorage) => {\n  var _class, _temp;\n\n  return _temp = _class = class PreferredSettingsApplicator extends React.Component {\n    componentDidMount() {\n      onPropsChanged({\n        setProperties: noop\n      }, this.props, localStorage, sessionStorage);\n    }\n\n    componentDidUpdate(prevProps) {\n      onPropsChanged(prevProps, this.props, localStorage, sessionStorage);\n    }\n\n    render() {\n      return null;\n    }\n\n  }, _defineProperty(_class, \"streamStateKeysForObservation\", ['playState', 'textTracks', 'audioTracks']), _temp;\n};\n\nexports.getPreferredSettingsApplicator = getPreferredSettingsApplicator;\nconst PreferredSettingsApplicator = (0, _connectControl.default)(getPreferredSettingsApplicator());\nvar _default = PreferredSettingsApplicator;\nexports.default = _default;","map":{"version":3,"sources":["../../../src/replay/components/player/settings-helpers/PreferredSettingsApplicator.js"],"names":["noop","getTrackFromLanguageAndKind","Array","tracks","track","getTrackToSelect","prevTracks","nextTracks","mergePreferredSettings","userSettingsConfig","configuration","storageKey","localSettings","sessionSettings","JSON","sessionStorage","localStorage","getPropsToBeUpdated","updates","nextPlayState","preferredSettings","audioTrackToSelect","textTrackToSelect","onPropsChanged","playState","audioTracks","textTracks","volume","isMuted","textTrackLanguage","textTrackKind","audioTrackLanguage","audioTrackKind","setProperties","nextProps","programmaticSettings","mergedSettings","propsToBeUpdated","prevProps","Object","getPreferredSettingsApplicator","window","React","componentDidMount","componentDidUpdate","render","PreferredSettingsApplicator"],"mappings":"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","sourcesContent":["// @flow\nimport * as React from 'react';\nimport connectControl from '../PlayerController/connectControl';\n\nimport type { AvailableTrack, PlayState } from '../VideoStreamer/types';\nimport type { StreamStateKeysForObservation, SetPropertiesMethod } from '../PlayerController/ControllerContext';\nimport type { PreferredSettings } from '../../../default-player/types';\n\ntype SettingsStorageKind = 'none' | 'local' | 'session';\n\nexport type UserSettingsConfiguration = {\n  userSettings?: {\n    hasPrecedence?: ?boolean,\n    storageKey?: string,\n    settingsStoragePolicy: {\n      volume?: ?SettingsStorageKind,\n      isMuted?: ?SettingsStorageKind,\n      textTrackLanguage?: ?SettingsStorageKind,\n      textTrackKind?: ?SettingsStorageKind,\n      audioTrackLanguage?: ?SettingsStorageKind,\n      audioTrackKind?: ?SettingsStorageKind\n    }\n  }\n};\n\ntype Props = PreferredSettings & {\n  textTracks?: Array<AvailableTrack>,\n  audioTracks?: Array<AvailableTrack>,\n  playState?: PlayState,\n  setProperties: SetPropertiesMethod,\n  configuration?: ?UserSettingsConfiguration\n};\n\nconst noop = () => {};\n\nconst getTrackFromLanguageAndKind = (\n  language: ?string,\n  kind: ?string,\n  tracks: ?Array<AvailableTrack>,\n  ignorableLength: number\n): ?AvailableTrack => {\n  if (Array.isArray(tracks) && tracks.length > ignorableLength) {\n    return (\n      tracks.filter(track => track.language === language && track.kind === kind)[0] ||\n      tracks.filter(track => track.language === language)[0] ||\n      tracks.filter(track => track.kind === kind)[0]\n    );\n  }\n};\n\nconst getTrackToSelect = (\n  preferredLanguage: ?string,\n  preferredKind: ?string,\n  prevTracks: ?Array<AvailableTrack>,\n  nextTracks: ?Array<AvailableTrack>,\n  ignorableTrackListLength: number\n) => {\n  if (prevTracks !== nextTracks && Array.isArray(nextTracks) && nextTracks.length > 0) {\n    return getTrackFromLanguageAndKind(preferredLanguage, preferredKind, nextTracks, ignorableTrackListLength);\n  }\n};\n\nconst mergePreferredSettings = (\n  configuration: ?UserSettingsConfiguration,\n  programmaticSettings: PreferredSettings,\n  localStorage: Storage,\n  sessionStorage: Storage\n): PreferredSettings => {\n  const userSettingsConfig = configuration && configuration.userSettings;\n  const storageKey = userSettingsConfig && userSettingsConfig.storageKey;\n  if (userSettingsConfig && storageKey) {\n    let localSettings = {};\n    let sessionSettings = {};\n    try {\n      sessionSettings = JSON.parse(sessionStorage.getItem(storageKey) || '{}');\n    } catch (e) {}\n    try {\n      localSettings = JSON.parse(localStorage.getItem(storageKey) || '{}');\n    } catch (e) {}\n    if (userSettingsConfig.hasPrecedence) {\n      return {\n        ...programmaticSettings,\n        ...localSettings,\n        ...sessionSettings\n      };\n    } else {\n      return {\n        ...localSettings,\n        ...sessionSettings,\n        ...programmaticSettings\n      };\n    }\n  } else {\n    return programmaticSettings;\n  }\n};\n\nconst getPropsToBeUpdated = (\n  prevPlayState: ?PlayState,\n  nextPlayState: ?PlayState,\n  prevAudioTracks: ?Array<AvailableTrack>,\n  prevTextTracks: ?Array<AvailableTrack>,\n  nextAudioTracks: ?Array<AvailableTrack>,\n  nextTextTracks: ?Array<AvailableTrack>,\n  preferredSettings: PreferredSettings\n) => {\n  const updates = {};\n\n  if (nextPlayState !== prevPlayState && nextPlayState === 'starting') {\n    if (preferredSettings.volume != null) {\n      updates.volume = preferredSettings.volume;\n    }\n    if (preferredSettings.isMuted != null) {\n      updates.isMuted = preferredSettings.isMuted;\n    }\n  }\n\n  const audioTrackToSelect = getTrackToSelect(\n    preferredSettings.audioTrackLanguage,\n    preferredSettings.audioTrackKind,\n    prevAudioTracks,\n    nextAudioTracks,\n    1\n  );\n  if (audioTrackToSelect) {\n    updates.selectedAudioTrack = audioTrackToSelect;\n  }\n\n  const textTrackToSelect = getTrackToSelect(\n    preferredSettings.textTrackLanguage,\n    preferredSettings.textTrackKind,\n    prevTextTracks,\n    nextTextTracks,\n    0\n  );\n  if (textTrackToSelect) {\n    updates.selectedTextTrack = textTrackToSelect;\n  }\n\n  return updates;\n};\n\nconst onPropsChanged = (prevProps: Props, nextProps: Props, localStorage: Storage, sessionStorage: Storage) => {\n  const {\n    configuration,\n    playState,\n    audioTracks,\n    textTracks,\n    volume,\n    isMuted,\n    textTrackLanguage,\n    textTrackKind,\n    audioTrackLanguage,\n    audioTrackKind,\n    setProperties\n  } = nextProps;\n\n  const programmaticSettings = {};\n  if (volume != null) {\n    programmaticSettings.volume = volume;\n  }\n  if (isMuted != null) {\n    programmaticSettings.isMuted = isMuted;\n  }\n  if (textTrackLanguage != null) {\n    programmaticSettings.textTrackLanguage = textTrackLanguage;\n  }\n  if (textTrackKind != null) {\n    programmaticSettings.textTrackKind = textTrackKind;\n  }\n  if (audioTrackLanguage != null) {\n    programmaticSettings.audioTrackLanguage = audioTrackLanguage;\n  }\n  if (audioTrackKind != null) {\n    programmaticSettings.audioTrackKind = audioTrackKind;\n  }\n\n  const mergedSettings = mergePreferredSettings(configuration, programmaticSettings, localStorage, sessionStorage);\n  const propsToBeUpdated = getPropsToBeUpdated(\n    prevProps.playState,\n    playState,\n    prevProps.audioTracks,\n    prevProps.textTracks,\n    audioTracks,\n    textTracks,\n    mergedSettings\n  );\n\n  if (Object.keys(propsToBeUpdated).length > 0) {\n    setProperties(propsToBeUpdated);\n  }\n};\n\n// Testable version:\nexport const getPreferredSettingsApplicator = (\n  localStorage: Storage = window.localStorage,\n  sessionStorage: Storage = window.sessionStorage\n) =>\n  class PreferredSettingsApplicator extends React.Component<Props> {\n    static streamStateKeysForObservation: StreamStateKeysForObservation = ['playState', 'textTracks', 'audioTracks'];\n    componentDidMount() {\n      onPropsChanged({ setProperties: noop }, this.props, localStorage, sessionStorage);\n    }\n    componentDidUpdate(prevProps: Props) {\n      onPropsChanged(prevProps, this.props, localStorage, sessionStorage);\n    }\n    render() {\n      return null;\n    }\n  };\n\nconst PreferredSettingsApplicator = connectControl(getPreferredSettingsApplicator());\n\nexport default PreferredSettingsApplicator;\n"]},"metadata":{},"sourceType":"script"}