{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0; // http://sample.vodobox.com/planete_interdite/planete_interdite_alternate.m3u8\n\n/*export type AudioTracksStateProps = {\n  audioTracks?: Array<AvailableTrack>,\n  currentAudioTrack?: ?AvailableTrack\n};*/\n\nlet id = 0;\n\nconst createManagedTrack = videoElementTrack => {\n  return {\n    selectableTrack: {\n      id: videoElementTrack.id == null ? \"audio-\".concat(++id) : videoElementTrack.id,\n      language: videoElementTrack.language || '',\n      kind: videoElementTrack.kind || '',\n      label: videoElementTrack.label || '',\n      origin: 'in-stream'\n    },\n    videoElementTrack\n  };\n};\n\nconst getAudioTrackManager = (videoElement, update) => {\n  let managedTracks = [];\n\n  function mapAudioTracks() {\n    // $FlowFixMe Array.from() doesn't seem to understand iterables from the DOM API.\n    managedTracks = videoElement.audioTracks ? Array.from(videoElement.audioTracks).map(createManagedTrack) : [];\n  }\n\n  function updateStreamStateProps(selectedTrack) {\n    const currentAudioTrack = selectedTrack || managedTracks.filter(mt => mt.videoElementTrack.enabled).map(mt => mt.selectableTrack)[0] || null; // TODO: Don't create a new array with new items every time. A deep equal comparison on availableTracks is needed.\n\n    update({\n      audioTracks: managedTracks.map(mt => mt.selectableTrack),\n      currentAudioTrack\n    });\n  }\n\n  function handleTrackAddOrRemove() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleTrackChange() {\n    updateStreamStateProps();\n  }\n\n  function setup() {\n    if (videoElement.audioTracks) {\n      videoElement.audioTracks.addEventListener('addtrack', handleTrackAddOrRemove);\n      videoElement.audioTracks.addEventListener('change', handleTrackChange);\n      videoElement.audioTracks.addEventListener('removetrack', handleTrackAddOrRemove);\n    }\n\n    handleSourceChange();\n  }\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack) {\n    const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedAudioTrack)[0];\n\n    if (managedTrack) {\n      managedTrack.videoElementTrack.enabled = true;\n    }\n  }\n\n  function cleanup() {\n    if (videoElement.audioTracks) {\n      videoElement.audioTracks.removeEventListener('addtrack', handleTrackAddOrRemove);\n      videoElement.audioTracks.removeEventListener('change', handleTrackChange);\n      videoElement.audioTracks.removeEventListener('removetrack', handleTrackAddOrRemove);\n    }\n\n    managedTracks = [];\n  }\n\n  function handleSourceChange() {\n    handleTrackAddOrRemove();\n  }\n\n  setup();\n  return {\n    cleanup,\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nvar _default = getAudioTrackManager;\nexports.default = _default;","map":{"version":3,"sources":["../../../../src/replay/components/player/VideoStreamer/BasicVideoStreamer/audioTrackManager.js"],"names":["id","createManagedTrack","videoElementTrack","selectableTrack","language","kind","label","origin","getAudioTrackManager","managedTracks","videoElement","Array","currentAudioTrack","selectedTrack","mt","update","audioTracks","mapAudioTracks","updateStreamStateProps","handleSourceChange","managedTrack","handleTrackAddOrRemove","setup","handleSelectedAudioTrackChange"],"mappings":"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","sourcesContent":["// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { AudioTrackManager } from '../common/types';\n\n// http://sample.vodobox.com/planete_interdite/planete_interdite_alternate.m3u8\n\n/*export type AudioTracksStateProps = {\n  audioTracks?: Array<AvailableTrack>,\n  currentAudioTrack?: ?AvailableTrack\n};*/\n\ntype ManagedAudioTrack = {\n  videoElementTrack: AudioTrack,\n  selectableTrack: AvailableTrack\n};\n\nlet id = 0;\n\nconst createManagedTrack = (videoElementTrack: AudioTrack): ManagedAudioTrack => {\n  return {\n    selectableTrack: {\n      id: videoElementTrack.id == null ? `audio-${++id}` : videoElementTrack.id,\n      language: videoElementTrack.language || '',\n      kind: videoElementTrack.kind || '',\n      label: videoElementTrack.label || '',\n      origin: 'in-stream'\n    },\n    videoElementTrack\n  };\n};\n\nconst getAudioTrackManager = (videoElement: HTMLVideoElement, update: VideoStreamState => void): AudioTrackManager => {\n  let managedTracks: Array<ManagedAudioTrack> = [];\n\n  function mapAudioTracks() {\n    // $FlowFixMe Array.from() doesn't seem to understand iterables from the DOM API.\n    managedTracks = videoElement.audioTracks ? Array.from(videoElement.audioTracks).map(createManagedTrack) : [];\n  }\n\n  function updateStreamStateProps(selectedTrack?: ?AvailableTrack) {\n    const currentAudioTrack =\n      selectedTrack ||\n      managedTracks.filter(mt => mt.videoElementTrack.enabled).map(mt => mt.selectableTrack)[0] ||\n      null;\n    // TODO: Don't create a new array with new items every time. A deep equal comparison on availableTracks is needed.\n    update({ audioTracks: managedTracks.map(mt => mt.selectableTrack), currentAudioTrack });\n  }\n\n  function handleTrackAddOrRemove() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleTrackChange() {\n    updateStreamStateProps();\n  }\n\n  function setup() {\n    if (videoElement.audioTracks) {\n      videoElement.audioTracks.addEventListener('addtrack', handleTrackAddOrRemove);\n      videoElement.audioTracks.addEventListener('change', handleTrackChange);\n      videoElement.audioTracks.addEventListener('removetrack', handleTrackAddOrRemove);\n    }\n    handleSourceChange();\n  }\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedAudioTrack)[0];\n    if (managedTrack) {\n      managedTrack.videoElementTrack.enabled = true;\n    }\n  }\n\n  function cleanup() {\n    if (videoElement.audioTracks) {\n      videoElement.audioTracks.removeEventListener('addtrack', handleTrackAddOrRemove);\n      videoElement.audioTracks.removeEventListener('change', handleTrackChange);\n      videoElement.audioTracks.removeEventListener('removetrack', handleTrackAddOrRemove);\n    }\n    managedTracks = [];\n  }\n\n  function handleSourceChange() {\n    handleTrackAddOrRemove();\n  }\n\n  setup();\n\n  return {\n    cleanup,\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getAudioTrackManager;\n"]},"metadata":{},"sourceType":"script"}