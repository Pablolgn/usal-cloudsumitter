{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst matchKeyCaseSafely = (key, eventKey) => {\n  return typeof key !== 'string' ? false : key.length > 1 ? key === eventKey : key.toLowerCase() === eventKey.toLowerCase();\n};\n\nconst getMatchingOperationFromKeyMap = (config, eventKey) => {\n  if (config.keyMap) {\n    return Object.entries(config.keyMap).filter(([_, mappedKeys]) => !!(matchKeyCaseSafely(mappedKeys, eventKey) || Array.isArray(mappedKeys) && mappedKeys.filter(key => matchKeyCaseSafely(key, eventKey)).length)).map(entry => entry[0])[0];\n  }\n};\n\nclass KeyboardShortcuts extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"handleKeyDown\", keyboardEvent => {\n      let _this$props = this.props,\n          nudge = _this$props.nudge,\n          toggleFixedUserActive = _this$props.toggleFixedUserActive,\n          configuration = _this$props.configuration,\n          setProperties = _this$props.setProperties,\n          fullscreenState = _this$props.fullscreenState,\n          isPaused = _this$props.isPaused,\n          isMuted = _this$props.isMuted,\n          position = _this$props.position,\n          duration = _this$props.duration,\n          volume = _this$props.volume,\n          playMode = _this$props.playMode,\n          inspect = _this$props.inspect;\n\n      if (inspect) {\n        const inspectedState = inspect();\n        isPaused = inspectedState.isPaused;\n        isMuted = inspectedState.isMuted;\n        position = inspectedState.position;\n        duration = inspectedState.duration;\n        volume = inspectedState.volume;\n        playMode = inspectedState.playMode;\n      }\n\n      if (configuration && configuration.keyboardShortcuts) {\n        const offset = configuration.keyboardShortcuts.skipOffset || 30;\n        const volumeStep = configuration.keyboardShortcuts.volumeStep || 0.1;\n        const operation = getMatchingOperationFromKeyMap(configuration.keyboardShortcuts, keyboardEvent.key);\n\n        if (operation) {\n          switch (operation) {\n            case 'togglePause':\n              setProperties && setProperties({\n                isPaused: !isPaused\n              });\n              break;\n\n            case 'toggleMute':\n              setProperties && setProperties({\n                isMuted: !isMuted\n              });\n              break;\n\n            case 'toggleFullscreen':\n              fullscreenState && fullscreenState.setProperties({\n                isFullscreen: !fullscreenState.isFullscreen\n              });\n              break;\n\n            case 'skipBack':\n              setProperties && position != null && setProperties({\n                position: Math.max(position - offset, 0)\n              });\n              break;\n\n            case 'skipForward':\n              if (setProperties && duration) {\n                const targetPosition = (position || 0) + offset; // Skipping to the very end is just annoying. Skipping to live position makes sense.\n\n                if (targetPosition < duration || playMode !== 'ondemand') {\n                  setProperties({\n                    position: Math.min(targetPosition, duration)\n                  });\n                }\n              }\n\n              break;\n\n            case 'decreaseVolume':\n              setProperties && volume != null && setProperties({\n                volume: Math.max(volume - volumeStep, 0)\n              });\n              break;\n\n            case 'increaseVolume':\n              setProperties && volume != null && setProperties({\n                volume: Math.min(volume + volumeStep, 1)\n              });\n              break;\n\n            case 'toggleUserActive':\n              if (toggleFixedUserActive) {\n                toggleFixedUserActive();\n              }\n\n              break;\n\n            default: // eslint requires default in switch. Can't see that this is a good case for such a requirement.\n\n          }\n\n          if (nudge && operation !== 'toggleUserActive') {\n            nudge();\n          }\n\n          keyboardEvent.preventDefault();\n        } else if (keyboardEvent.key === 'Tab' && nudge) {\n          nudge();\n        }\n      }\n    });\n  }\n\n  render() {\n    const handleKeyDown = this.handleKeyDown;\n    return this.props.render({\n      handleKeyDown\n    });\n  }\n\n}\n\nvar _default = KeyboardShortcuts;\nexports.default = _default;","map":{"version":3,"sources":["../../../src/replay/components/player/containment-helpers/KeyboardShortcuts.js"],"names":["matchKeyCaseSafely","key","eventKey","getMatchingOperationFromKeyMap","config","Object","Array","mappedKeys","entry","React","keyboardEvent","nudge","toggleFixedUserActive","configuration","setProperties","fullscreenState","isPaused","isMuted","position","duration","volume","playMode","inspect","inspectedState","offset","volumeStep","operation","isFullscreen","Math","targetPosition","render","handleKeyDown","KeyboardShortcuts"],"mappings":"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","sourcesContent":["// @flow\nimport * as React from 'react';\nimport type { PlayMode } from '../VideoStreamer/types';\nimport type { FullscreenState } from './Fullscreen';\nimport type { InspectMethod } from '../PlayerController/ControllerContext';\n\ntype RenderParameters = {\n  handleKeyDown: KeyboardEvent => void\n};\n\ntype KeyMapping = string | Array<string>;\n\nexport type KeyboardShortcutsConfiguration = {\n  keyMap: {\n    togglePause?: KeyMapping,\n    toggleMute?: KeyMapping,\n    toggleFullscreen?: KeyMapping,\n    skipBack?: KeyMapping,\n    skipForward?: KeyMapping,\n    increaseVolume?: KeyMapping,\n    decreaseVolume?: KeyMapping\n  },\n  volumeStep?: number,\n  skipOffset?: number\n};\n\ntype UpdateableProperties = { volume: number } | { isMuted: boolean } | { isPaused: boolean } | { position: number };\n\ntype Props = {\n  nudge?: () => void,\n  toggleFixedUserActive?: () => void,\n  configuration?: {\n    keyboardShortcuts?: KeyboardShortcutsConfiguration\n  },\n  playMode?: ?PlayMode,\n  setProperties?: UpdateableProperties => void,\n  fullscreenState?: FullscreenState,\n  render: RenderParameters => React.Node,\n  isPaused?: ?boolean,\n  isMuted?: ?boolean,\n  position?: ?number,\n  duration?: ?number,\n  volume?: ?number,\n  inspect?: InspectMethod\n};\n\nconst matchKeyCaseSafely = (key: ?(string | any), eventKey: string): boolean => {\n  return typeof key !== 'string'\n    ? false\n    : key.length > 1\n    ? key === eventKey\n    : key.toLowerCase() === eventKey.toLowerCase();\n};\n\nconst getMatchingOperationFromKeyMap = (config: KeyboardShortcutsConfiguration, eventKey: string): ?string => {\n  if (config.keyMap) {\n    return Object.entries(config.keyMap)\n      .filter(\n        ([_, mappedKeys]) =>\n          !!(\n            matchKeyCaseSafely(mappedKeys, eventKey) ||\n            (Array.isArray(mappedKeys) && mappedKeys.filter(key => matchKeyCaseSafely(key, eventKey)).length)\n          )\n      )\n      .map(entry => entry[0])[0];\n  }\n};\n\nclass KeyboardShortcuts extends React.Component<Props> {\n  handleKeyDown = (keyboardEvent: KeyboardEvent) => {\n    let {\n      nudge,\n      toggleFixedUserActive,\n      configuration,\n      setProperties,\n      fullscreenState,\n      isPaused,\n      isMuted,\n      position,\n      duration,\n      volume,\n      playMode,\n      inspect\n    } = this.props;\n    if (inspect) {\n      const inspectedState = inspect();\n      isPaused = inspectedState.isPaused;\n      isMuted = inspectedState.isMuted;\n      position = inspectedState.position;\n      duration = inspectedState.duration;\n      volume = inspectedState.volume;\n      playMode = inspectedState.playMode;\n    }\n\n    if (configuration && configuration.keyboardShortcuts) {\n      const offset = configuration.keyboardShortcuts.skipOffset || 30;\n      const volumeStep = configuration.keyboardShortcuts.volumeStep || 0.1;\n      const operation = getMatchingOperationFromKeyMap(configuration.keyboardShortcuts, keyboardEvent.key);\n      if (operation) {\n        switch (operation) {\n          case 'togglePause':\n            setProperties && setProperties({ isPaused: !isPaused });\n            break;\n          case 'toggleMute':\n            setProperties && setProperties({ isMuted: !isMuted });\n            break;\n          case 'toggleFullscreen':\n            fullscreenState && fullscreenState.setProperties({ isFullscreen: !fullscreenState.isFullscreen });\n            break;\n          case 'skipBack':\n            setProperties && position != null && setProperties({ position: Math.max(position - offset, 0) });\n            break;\n          case 'skipForward':\n            if (setProperties && duration) {\n              const targetPosition = (position || 0) + offset;\n              // Skipping to the very end is just annoying. Skipping to live position makes sense.\n              if (targetPosition < duration || playMode !== 'ondemand') {\n                setProperties({ position: Math.min(targetPosition, duration) });\n              }\n            }\n            break;\n          case 'decreaseVolume':\n            setProperties && volume != null && setProperties({ volume: Math.max(volume - volumeStep, 0) });\n            break;\n          case 'increaseVolume':\n            setProperties && volume != null && setProperties({ volume: Math.min(volume + volumeStep, 1) });\n            break;\n          case 'toggleUserActive':\n            if (toggleFixedUserActive) {\n              toggleFixedUserActive();\n            }\n            break;\n          default:\n          // eslint requires default in switch. Can't see that this is a good case for such a requirement.\n        }\n        if (nudge && operation !== 'toggleUserActive') {\n          nudge();\n        }\n        keyboardEvent.preventDefault();\n      } else if (keyboardEvent.key === 'Tab' && nudge) {\n        nudge();\n      }\n    }\n  };\n\n  render() {\n    const { handleKeyDown } = this;\n    return this.props.render({ handleKeyDown });\n  }\n}\nexport default KeyboardShortcuts;\n"]},"metadata":{},"sourceType":"script"}