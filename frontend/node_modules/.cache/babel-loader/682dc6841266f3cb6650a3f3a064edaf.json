{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _Selector = _interopRequireDefault(require(\"../../generic/Selector/Selector\"));\n\nvar _common = require(\"../../common\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst className = 'quality-selector';\n\nclass QualitySelector extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"handleSelect\", bitrate => {\n      if (this.props.setProperties) {\n        if (this.props.selectionStrategy === 'fix-bitrate') {\n          this.props.setProperties({\n            bitrateFix: bitrate\n          });\n        } else {\n          this.props.setProperties({\n            bitrateCap: bitrate\n          });\n        }\n      }\n    });\n\n    _defineProperty(this, \"bitrateToItem\", bitrate => ({\n      id: bitrate,\n      label: bitrate === Infinity ? this.props.autoLabel : this.props.formatBitrateLabel(bitrate, bitrate === this.props.currentBitrate),\n      data: bitrate\n    }));\n\n    _defineProperty(this, \"isSelected\", (bitrate, index, arr) => {\n      const _this$props = this.props,\n            bitrateFix = _this$props.bitrateFix,\n            bitrateCap = _this$props.bitrateCap,\n            selectionStrategy = _this$props.selectionStrategy;\n      const matchValue = bitrateFix != null && bitrateCap != null ? selectionStrategy === 'fix-bitrate' ? bitrateFix : bitrateCap : bitrateFix || bitrateCap;\n\n      if (matchValue === 'min') {\n        return index === 1;\n      } else if (matchValue === 'max') {\n        return index === arr.length - 1;\n      } else {\n        return bitrate === matchValue;\n      }\n    });\n  }\n\n  render() {\n    const _this$props2 = this.props,\n          bitrates = _this$props2.bitrates,\n          label = _this$props2.label,\n          toggleContent = _this$props2.toggleContent,\n          classNamePrefix = _this$props2.classNamePrefix;\n\n    if (Array.isArray(bitrates) && bitrates.length > 1) {\n      const items = [Infinity].concat(bitrates);\n      const selectedItem = items.filter(this.isSelected)[0] || items[0];\n      return /*#__PURE__*/React.createElement(_Selector.default, {\n        items: items,\n        itemMapper: this.bitrateToItem,\n        classNamePrefix: classNamePrefix,\n        className: className,\n        selectedItem: selectedItem,\n        label: label,\n        onSelect: this.handleSelect,\n        reverseOrder: true,\n        expandedToggleContent: toggleContent,\n        collapsedToggleContent: toggleContent\n      });\n    } else {\n      return null;\n    }\n  }\n\n}\n\n_defineProperty(QualitySelector, \"defaultProps\", {\n  classNamePrefix: _common.defaultClassNamePrefix,\n  selectionStrategy: 'cap-bitrate'\n});\n\n_defineProperty(QualitySelector, \"streamStateKeysForObservation\", ['bitrates', 'currentBitrate', 'bitrateFix', 'bitrateCap']);\n\nQualitySelector.displayName = 'QualitySelector';\nvar _default = QualitySelector;\nexports.default = _default;","map":{"version":3,"sources":["../../../src/replay/components/controls/QualitySelector/QualitySelector.js"],"names":["className","QualitySelector","React","classNamePrefix","defaultClassNamePrefix","selectionStrategy","bitrate","bitrateFix","bitrateCap","id","label","data","matchValue","index","arr","render","bitrates","toggleContent","Array","items","selectedItem"],"mappings":"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","sourcesContent":["// @flow\nimport * as React from 'react';\nimport Selector from '../../generic/Selector/Selector';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { CommonProps } from '../../common';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\n\nexport type QualitySelectionStrategy = 'cap-bitrate' | 'fix-bitrate';\n\ntype Props = CommonProps & {\n  /** ⇘︎ The list of bitrates available for adaptive selection, and for being fixed or set as cap level. */\n  bitrates?: Array<number>,\n  /** ⇘︎ The currently playing bitrate. */\n  currentBitrate?: number,\n  /** ⇘︎ If playback is (already) fixed to one bitrate, this prop is set. */\n  bitrateFix?: ?number,\n  /** ⇘︎ If adaptive bitrate selection is (already) capped at a level, this prop is set. */\n  bitrateCap?: ?number,\n  /** The content of the toggle button of the selector. */\n  toggleContent: React.Node,\n  /** ⇗ When one item is clicked, this callback is invoked with an object having a property with either the name bitrateCap or bitrateFix and a value according to the selected bitrate. For the auto option, the value is Infinity. */\n  setProperties?: ({ bitrateFix: ?number } | { bitrateCap: ?number }) => void,\n  /** Configures whether the selector should specify bitrate cap or fixing. */\n  selectionStrategy?: QualitySelectionStrategy,\n  /** The label for the selector item used for resetting capped or fixed bitrate. */\n  autoLabel: string,\n  /** Should return the item text to be displayed for each bitrate. The second argument indicates if the bitrate is currently playing. */\n  formatBitrateLabel: (number, boolean) => string\n};\n\nconst className = 'quality-selector';\n\nclass QualitySelector extends React.Component<Props> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix,\n    selectionStrategy: 'cap-bitrate'\n  };\n\n  static streamStateKeysForObservation: StreamStateKeysForObservation = [\n    'bitrates',\n    'currentBitrate',\n    'bitrateFix',\n    'bitrateCap'\n  ];\n\n  handleSelect = (bitrate: number) => {\n    if (this.props.setProperties) {\n      if (this.props.selectionStrategy === 'fix-bitrate') {\n        this.props.setProperties({ bitrateFix: bitrate });\n      } else {\n        this.props.setProperties({ bitrateCap: bitrate });\n      }\n    }\n  };\n\n  bitrateToItem = (bitrate: number) => ({\n    id: bitrate,\n    label:\n      bitrate === Infinity\n        ? this.props.autoLabel\n        : this.props.formatBitrateLabel(bitrate, bitrate === this.props.currentBitrate),\n    data: bitrate\n  });\n\n  isSelected = (bitrate: number, index: number, arr: Array<number>) => {\n    const { bitrateFix, bitrateCap, selectionStrategy } = this.props;\n    const matchValue =\n      bitrateFix != null && bitrateCap != null\n        ? selectionStrategy === 'fix-bitrate'\n          ? bitrateFix\n          : bitrateCap\n        : bitrateFix || bitrateCap;\n    if (matchValue === 'min') {\n      return index === 1;\n    } else if (matchValue === 'max') {\n      return index === arr.length - 1;\n    } else {\n      return bitrate === matchValue;\n    }\n  };\n\n  render() {\n    const { bitrates, label, toggleContent, classNamePrefix } = this.props;\n    if (Array.isArray(bitrates) && bitrates.length > 1) {\n      const items = [Infinity].concat(bitrates);\n      const selectedItem = items.filter(this.isSelected)[0] || items[0];\n\n      return (\n        <Selector\n          items={items}\n          itemMapper={this.bitrateToItem}\n          classNamePrefix={classNamePrefix}\n          className={className}\n          selectedItem={selectedItem}\n          label={label}\n          onSelect={this.handleSelect}\n          reverseOrder={true}\n          expandedToggleContent={toggleContent}\n          collapsedToggleContent={toggleContent}\n        />\n      );\n    } else {\n      return null;\n    }\n  }\n}\n\nQualitySelector.displayName = 'QualitySelector';\nexport default QualitySelector;\n"]},"metadata":{},"sourceType":"script"}