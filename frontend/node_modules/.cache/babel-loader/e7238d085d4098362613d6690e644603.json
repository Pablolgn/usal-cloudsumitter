{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _common = require(\"../../common\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst baseClassName = 'slider';\nconst isDraggingClassName = 'dragging';\nconst wasClickedClassName = 'clicked';\nconst baseTrackClassName = 'slider-track';\nconst baseHandleClassName = 'slider-handle';\nconst zeroStyle = '0%';\nconst horizontalProp = 'left';\nconst verticalProp = 'bottom';\nconst keyPressValueStep = 0.025;\n\nconst selectDefaultClasses = classes => classes.slider;\n\nconst selectDraggingClasses = classes => classes.sliderDragging || classes.slider;\n\nconst selectTrackClasses = classes => classes.sliderTrack;\n\nconst selectHandleClasses = classes => classes.sliderHandle;\n\nfunction toPercentString(value, maxValue) {\n  const attempt = value / maxValue;\n\n  if (maxValue === Infinity || value === Infinity || maxValue === 0 || isNaN(attempt) || attempt === 0) {\n    return zeroStyle;\n  } else {\n    return \"\".concat((Math.min(1, attempt) * 100).toFixed(3), \"%\");\n  }\n}\n/*\n\nThe styling of the slider needs to follow some rules in order to get sensible responses from user interactions:\n\n* The draggable or clickable area will be the size of the track element (remember how margin, borders, padding, box-sizing, etc. affects the size).\n* The handle positioning (between 0 and 100 percent from left or bottom) should align with the track size and placement.\n* The styling needs to take into account the size of the handle itself. The component will not subtract the size of the component in its positioning and value calculations.\n* The handle should ideally be shifted half its width to the left for horizontal sliders, or half its height down for vertical sliders. It is the center coordinate that should count.\n\n */\n\n\nconst decreaseKeys = ['Left', 'ArrowLeft', 'Down', 'ArrowDown'];\nconst increaseKeys = ['Right', 'ArrowRight', 'Up', 'ArrowUp'];\nconst allCaptureKeys = decreaseKeys.concat(increaseKeys);\n\nclass Slider extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"renderedHandle\", void 0);\n\n    _defineProperty(this, \"renderedTrack\", void 0);\n\n    _defineProperty(this, \"isTouchSupported\", void 0);\n\n    _defineProperty(this, \"updateValueFromCoordinates\", (evt, conditions) => {\n      if (this.renderedTrack) {\n        const clickCoordinates = (0, _common.getBoundingEventCoordinates)(evt, this.renderedTrack);\n\n        if (this.props.isVertical) {\n          const relativeVerticalValue = (clickCoordinates.height - clickCoordinates.y) / clickCoordinates.height;\n          this.updateValue(relativeVerticalValue, conditions);\n        } else {\n          const relativeHorizontalValue = clickCoordinates.x / clickCoordinates.width;\n          this.updateValue(relativeHorizontalValue, conditions);\n        }\n      }\n    });\n\n    _defineProperty(this, \"updateValue\", (relativeValue, {\n      isDragging,\n      isEnded,\n      isPreviewing\n    }) => {\n      const value = relativeValue * this.props.maxValue;\n\n      if (isPreviewing) {\n        this.setState({\n          previewValue: value\n        });\n      } else {\n        if (this.state.isDragging) {\n          this.setState({\n            dragValue: value,\n            previewValue: value\n          });\n\n          if (this.props.onDrag) {\n            this.props.onDrag(value);\n          }\n        }\n\n        if (this.props.onValueChange && (isEnded || !(this.state.isDragging || isDragging))) {\n          this.props.onValueChange(value);\n        }\n      }\n    });\n\n    _defineProperty(this, \"handleHandleOrTrackClick\", evt => {\n      this.updateValueFromCoordinates(evt, {});\n    });\n\n    _defineProperty(this, \"handleHandleStartDrag\", evt => {\n      if (evt.type !== 'touchstart') {\n        evt.stopPropagation();\n      }\n\n      if (!this.state.isDragging) {\n        setTimeout(() => this.setState({\n          wasClicked: false\n        }), 1000);\n        this.setState({\n          isDragging: true,\n          wasClicked: true\n        });\n        this.updateValueFromCoordinates(evt, {\n          isDragging: true\n        }); // We are OK with no position updates yet.\n\n        if (this.isTouchSupported) {\n          document.addEventListener('touchmove', this.handleHandleDrag);\n          document.addEventListener('touchend', this.handleHandleEndDrag);\n          document.addEventListener('touchcancel', this.handleHandleEndDrag);\n        } else {\n          document.addEventListener('mousemove', this.handleHandleDrag);\n          document.addEventListener('mouseup', this.handleHandleEndDrag);\n          document.addEventListener('mouseleave', this.handleHandleEndDrag);\n        }\n      }\n    });\n\n    _defineProperty(this, \"handleHandleDrag\", evt => {\n      if (this.state.isDragging) {\n        this.updateValueFromCoordinates(evt, {});\n      } else {\n        this.updateValueFromCoordinates(evt, {\n          isPreviewing: true\n        });\n      }\n    });\n\n    _defineProperty(this, \"handleHandleEndDrag\", evt => {\n      if (this.state.isDragging) {\n        this.updateValueFromCoordinates(evt, {\n          isDragging: true,\n          isEnded: true\n        });\n      }\n\n      if (this.isTouchSupported) {\n        document.removeEventListener('touchmove', this.handleHandleDrag);\n        document.removeEventListener('touchend', this.handleHandleEndDrag);\n        document.removeEventListener('touchcancel', this.handleHandleEndDrag);\n      } else {\n        document.removeEventListener('mousemove', this.handleHandleDrag);\n        document.removeEventListener('mouseup', this.handleHandleEndDrag);\n        document.removeEventListener('mouseleave', this.handleHandleEndDrag);\n      }\n\n      this.setState({\n        isDragging: false\n      });\n    });\n\n    _defineProperty(this, \"handleMouseEnter\", () => {\n      this.setState({\n        isPointerInside: true\n      });\n    });\n\n    _defineProperty(this, \"handleMouseLeave\", () => {\n      this.setState({\n        isPointerInside: false\n      });\n    });\n\n    _defineProperty(this, \"handleKeyDown\", (0, _common.getKeyboardShortcutBlocker)(allCaptureKeys));\n\n    _defineProperty(this, \"handleKeyUp\", keyboardEvent => {\n      if (!isNaN(this.props.value) && !isNaN(this.props.maxValue)) {\n        const relativeValue = this.props.value / this.props.maxValue;\n\n        if (decreaseKeys.indexOf(keyboardEvent.key) >= 0) {\n          this.updateValue(Math.max(0, relativeValue - keyPressValueStep), {});\n        }\n\n        if (increaseKeys.indexOf(keyboardEvent.key) >= 0) {\n          this.updateValue(Math.min(1, relativeValue + keyPressValueStep), {});\n        }\n      }\n    });\n\n    _defineProperty(this, \"setRenderedHandle\", handle => {\n      this.renderedHandle = handle;\n    });\n\n    _defineProperty(this, \"setRenderedTrack\", track => {\n      this.renderedTrack = track;\n    });\n\n    this.isTouchSupported = 'ontouchend' in window;\n    this.state = {};\n  }\n\n  render() {\n    const _this$props = this.props,\n          children = _this$props.children,\n          handleContent = _this$props.handleContent,\n          trackContent = _this$props.trackContent,\n          classNamePrefix = _this$props.classNamePrefix,\n          className = _this$props.className,\n          classes = _this$props.classes,\n          handleClassName = _this$props.handleClassName,\n          trackClassName = _this$props.trackClassName,\n          label = _this$props.label,\n          isVertical = _this$props.isVertical,\n          value = _this$props.value,\n          maxValue = _this$props.maxValue,\n          isUpdateBlocked = _this$props.isUpdateBlocked;\n    const _this$state = this.state,\n          dragValue = _this$state.dragValue,\n          previewValue = _this$state.previewValue,\n          isDragging = _this$state.isDragging,\n          isPointerInside = _this$state.isPointerInside,\n          wasClicked = _this$state.wasClicked;\n    const displayValue = (isDragging || isUpdateBlocked) && dragValue != null ? dragValue : value;\n    const selectClasses = isDragging ? selectDraggingClasses : selectDefaultClasses;\n    const sliderClassNames = (0, _common.hydrateClassNames)({\n      classes,\n      selectClasses,\n      classNamePrefix,\n      classNames: [baseClassName, className, isDragging ? isDraggingClassName : null, wasClicked ? wasClickedClassName : null]\n    });\n    const handleClassNames = (0, _common.hydrateClassNames)({\n      classes,\n      selectClasses: selectHandleClasses,\n      classNamePrefix,\n      classNames: [baseHandleClassName, handleClassName]\n    });\n    const trackClassNames = (0, _common.hydrateClassNames)({\n      classes,\n      selectClasses: selectTrackClasses,\n      classNamePrefix,\n      classNames: [baseTrackClassName, trackClassName]\n    });\n    return /*#__PURE__*/React.createElement(\"div\", {\n      onClick: this.handleHandleOrTrackClick,\n      onMouseDown: this.handleHandleStartDrag,\n      onTouchStart: this.handleHandleStartDrag,\n      onTouchMove: this.handleHandleDrag,\n      onTouchEnd: this.handleHandleEndDrag,\n      onMouseUp: this.handleHandleEndDrag,\n      onMouseMove: this.handleHandleDrag,\n      onMouseEnter: this.handleMouseEnter,\n      onMouseLeave: this.handleMouseLeave,\n      onKeyDown: this.handleKeyDown,\n      onKeyUp: this.handleKeyUp,\n      title: label,\n      role: \"slider\",\n      \"aria-valuemin\": 0,\n      \"aria-valuemax\": maxValue,\n      \"aria-valuenow\": value,\n      className: sliderClassNames,\n      tabIndex: 0\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: trackClassNames,\n      ref: this.setRenderedTrack\n    }, trackContent), React.Children.map(children, child => React.cloneElement(child, {\n      previewValue,\n      isDragging,\n      isPointerInside\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: handleClassNames,\n      style: {\n        [isVertical ? verticalProp : horizontalProp]: toPercentString(displayValue, maxValue)\n      },\n      role: \"button\",\n      tabIndex: -1,\n      ref: this.setRenderedHandle\n    }, handleContent));\n  }\n\n}\n\n_defineProperty(Slider, \"defaultProps\", {\n  value: 0,\n  maxValue: 1\n});\n\nvar _default = Slider;\n/*\n\nConsider moving all events to track or slider itself. Or moving track on top of children!\n\n */\n\n/* Assumptions\n\nClickable area = track length OR is it slider length?\nIf track length - should we assume that it aligns with possible handle min/max positions?\n\n*/\n\nexports.default = _default;","map":{"version":3,"sources":["../../../src/replay/components/generic/Slider/Slider.js"],"names":["baseClassName","isDraggingClassName","wasClickedClassName","baseTrackClassName","baseHandleClassName","zeroStyle","horizontalProp","verticalProp","keyPressValueStep","selectDefaultClasses","classes","selectDraggingClasses","selectTrackClasses","selectHandleClasses","attempt","value","maxValue","isNaN","Math","decreaseKeys","increaseKeys","allCaptureKeys","Slider","React","constructor","clickCoordinates","relativeVerticalValue","relativeHorizontalValue","isPreviewing","relativeValue","previewValue","dragValue","isEnded","evt","setTimeout","wasClicked","isDragging","document","isPointerInside","keyboardEvent","handle","track","render","children","handleContent","trackContent","classNamePrefix","className","handleClassName","trackClassName","label","isVertical","isUpdateBlocked","displayValue","selectClasses","sliderClassNames","classNames","handleClassNames","trackClassNames","setRenderedTrack","child","toPercentString","setRenderedHandle"],"mappings":"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","sourcesContent":["// @flow\nimport * as React from 'react';\nimport {\n  type CommonGenericProps,\n  getBoundingEventCoordinates,\n  getKeyboardShortcutBlocker,\n  hydrateClassNames\n} from '../../common';\n\ntype Props = CommonGenericProps & {\n  value: number,\n  maxValue: number,\n  isUpdateBlocked?: boolean,\n  isVertical?: boolean,\n  children?: React.Node,\n  handleContent?: React.Node,\n  handleClassName?: string,\n  trackContent?: React.Node,\n  trackClassName?: string,\n  label?: string,\n  onValueChange?: number => void,\n  onDrag?: number => void\n};\n\ntype State = {\n  dragValue?: number,\n  isDragging?: boolean,\n  wasClicked?: boolean,\n  previewValue?: number,\n  isPointerInside?: boolean\n};\n\ntype UpdateConditions = {\n  isDragging?: boolean,\n  isEnded?: boolean,\n  isPreviewing?: boolean\n};\n\nconst baseClassName = 'slider';\nconst isDraggingClassName = 'dragging';\nconst wasClickedClassName = 'clicked';\nconst baseTrackClassName = 'slider-track';\nconst baseHandleClassName = 'slider-handle';\nconst zeroStyle = '0%';\nconst horizontalProp = 'left';\nconst verticalProp = 'bottom';\nconst keyPressValueStep = 0.025;\n\nconst selectDefaultClasses = classes => classes.slider;\nconst selectDraggingClasses = classes => classes.sliderDragging || classes.slider;\nconst selectTrackClasses = classes => classes.sliderTrack;\nconst selectHandleClasses = classes => classes.sliderHandle;\n\nfunction toPercentString(value: number, maxValue: number): string {\n  const attempt = value / maxValue;\n  if (maxValue === Infinity || value === Infinity || maxValue === 0 || isNaN(attempt) || attempt === 0) {\n    return zeroStyle;\n  } else {\n    return `${(Math.min(1, attempt) * 100).toFixed(3)}%`;\n  }\n}\n\n/*\n\nThe styling of the slider needs to follow some rules in order to get sensible responses from user interactions:\n\n* The draggable or clickable area will be the size of the track element (remember how margin, borders, padding, box-sizing, etc. affects the size).\n* The handle positioning (between 0 and 100 percent from left or bottom) should align with the track size and placement.\n* The styling needs to take into account the size of the handle itself. The component will not subtract the size of the component in its positioning and value calculations.\n* The handle should ideally be shifted half its width to the left for horizontal sliders, or half its height down for vertical sliders. It is the center coordinate that should count.\n\n */\n\nconst decreaseKeys = ['Left', 'ArrowLeft', 'Down', 'ArrowDown'];\nconst increaseKeys = ['Right', 'ArrowRight', 'Up', 'ArrowUp'];\nconst allCaptureKeys = decreaseKeys.concat(increaseKeys);\n\nclass Slider extends React.Component<Props, State> {\n  static defaultProps = {\n    value: 0,\n    maxValue: 1\n  };\n\n  renderedHandle: ?HTMLDivElement;\n  renderedTrack: ?HTMLDivElement;\n  isTouchSupported: boolean;\n\n  constructor(props: Props) {\n    super(props);\n    this.isTouchSupported = 'ontouchend' in window;\n    this.state = {};\n  }\n\n  updateValueFromCoordinates = (\n    evt: SyntheticMouseEvent<HTMLDivElement> | MouseEvent | TouchEvent,\n    conditions: UpdateConditions\n  ) => {\n    if (this.renderedTrack) {\n      const clickCoordinates = getBoundingEventCoordinates(evt, this.renderedTrack);\n      if (this.props.isVertical) {\n        const relativeVerticalValue = (clickCoordinates.height - clickCoordinates.y) / clickCoordinates.height;\n        this.updateValue(relativeVerticalValue, conditions);\n      } else {\n        const relativeHorizontalValue = clickCoordinates.x / clickCoordinates.width;\n        this.updateValue(relativeHorizontalValue, conditions);\n      }\n    }\n  };\n\n  updateValue = (relativeValue: number, { isDragging, isEnded, isPreviewing }: UpdateConditions) => {\n    const value = relativeValue * this.props.maxValue;\n    if (isPreviewing) {\n      this.setState({\n        previewValue: value\n      });\n    } else {\n      if (this.state.isDragging) {\n        this.setState({\n          dragValue: value,\n          previewValue: value\n        });\n        if (this.props.onDrag) {\n          this.props.onDrag(value);\n        }\n      }\n      if (this.props.onValueChange && (isEnded || !(this.state.isDragging || isDragging))) {\n        this.props.onValueChange(value);\n      }\n    }\n  };\n\n  handleHandleOrTrackClick = (evt: SyntheticMouseEvent<HTMLDivElement>) => {\n    this.updateValueFromCoordinates(evt, {});\n  };\n\n  handleHandleStartDrag = (evt: SyntheticMouseEvent<HTMLDivElement>) => {\n    if (evt.type !== 'touchstart') {\n      evt.stopPropagation();\n    }\n    if (!this.state.isDragging) {\n      setTimeout(() => this.setState({ wasClicked: false }), 1000);\n      this.setState({ isDragging: true, wasClicked: true });\n      this.updateValueFromCoordinates(evt, { isDragging: true });\n      // We are OK with no position updates yet.\n      if (this.isTouchSupported) {\n        document.addEventListener('touchmove', this.handleHandleDrag);\n        document.addEventListener('touchend', this.handleHandleEndDrag);\n        document.addEventListener('touchcancel', this.handleHandleEndDrag);\n      } else {\n        document.addEventListener('mousemove', this.handleHandleDrag);\n        document.addEventListener('mouseup', this.handleHandleEndDrag);\n        document.addEventListener('mouseleave', this.handleHandleEndDrag);\n      }\n    }\n  };\n\n  handleHandleDrag = (evt: SyntheticMouseEvent<HTMLDivElement> | MouseEvent | TouchEvent) => {\n    if (this.state.isDragging) {\n      this.updateValueFromCoordinates(evt, {});\n    } else {\n      this.updateValueFromCoordinates(evt, { isPreviewing: true });\n    }\n  };\n\n  handleHandleEndDrag = (evt: SyntheticMouseEvent<HTMLDivElement> | MouseEvent | TouchEvent) => {\n    if (this.state.isDragging) {\n      this.updateValueFromCoordinates(evt, { isDragging: true, isEnded: true });\n    }\n    if (this.isTouchSupported) {\n      document.removeEventListener('touchmove', this.handleHandleDrag);\n      document.removeEventListener('touchend', this.handleHandleEndDrag);\n      document.removeEventListener('touchcancel', this.handleHandleEndDrag);\n    } else {\n      document.removeEventListener('mousemove', this.handleHandleDrag);\n      document.removeEventListener('mouseup', this.handleHandleEndDrag);\n      document.removeEventListener('mouseleave', this.handleHandleEndDrag);\n    }\n    this.setState({ isDragging: false });\n  };\n\n  handleMouseEnter = () => {\n    this.setState({ isPointerInside: true });\n  };\n  handleMouseLeave = () => {\n    this.setState({ isPointerInside: false });\n  };\n\n  handleKeyDown = getKeyboardShortcutBlocker(allCaptureKeys);\n\n  handleKeyUp = (keyboardEvent: KeyboardEvent) => {\n    if (!isNaN(this.props.value) && !isNaN(this.props.maxValue)) {\n      const relativeValue = this.props.value / this.props.maxValue;\n      if (decreaseKeys.indexOf(keyboardEvent.key) >= 0) {\n        this.updateValue(Math.max(0, relativeValue - keyPressValueStep), {});\n      }\n      if (increaseKeys.indexOf(keyboardEvent.key) >= 0) {\n        this.updateValue(Math.min(1, relativeValue + keyPressValueStep), {});\n      }\n    }\n  };\n\n  setRenderedHandle = (handle: ?HTMLDivElement) => {\n    this.renderedHandle = handle;\n  };\n\n  setRenderedTrack = (track: ?HTMLDivElement) => {\n    this.renderedTrack = track;\n  };\n\n  render() {\n    const {\n      children,\n      handleContent,\n      trackContent,\n      classNamePrefix,\n      className,\n      classes,\n      handleClassName,\n      trackClassName,\n      label,\n      isVertical,\n      value,\n      maxValue,\n      isUpdateBlocked\n    } = this.props;\n    const { dragValue, previewValue, isDragging, isPointerInside, wasClicked } = this.state;\n    const displayValue = (isDragging || isUpdateBlocked) && dragValue != null ? dragValue : value;\n    const selectClasses = isDragging ? selectDraggingClasses : selectDefaultClasses;\n    const sliderClassNames = hydrateClassNames({\n      classes,\n      selectClasses,\n      classNamePrefix,\n      classNames: [\n        baseClassName,\n        className,\n        isDragging ? isDraggingClassName : null,\n        wasClicked ? wasClickedClassName : null\n      ]\n    });\n    const handleClassNames = hydrateClassNames({\n      classes,\n      selectClasses: selectHandleClasses,\n      classNamePrefix,\n      classNames: [baseHandleClassName, handleClassName]\n    });\n    const trackClassNames = hydrateClassNames({\n      classes,\n      selectClasses: selectTrackClasses,\n      classNamePrefix,\n      classNames: [baseTrackClassName, trackClassName]\n    });\n    return (\n      <div\n        onClick={this.handleHandleOrTrackClick}\n        onMouseDown={this.handleHandleStartDrag}\n        onTouchStart={this.handleHandleStartDrag}\n        onTouchMove={this.handleHandleDrag}\n        onTouchEnd={this.handleHandleEndDrag}\n        onMouseUp={this.handleHandleEndDrag}\n        onMouseMove={this.handleHandleDrag}\n        onMouseEnter={this.handleMouseEnter}\n        onMouseLeave={this.handleMouseLeave}\n        onKeyDown={this.handleKeyDown}\n        onKeyUp={this.handleKeyUp}\n        title={label}\n        role=\"slider\"\n        aria-valuemin={0}\n        aria-valuemax={maxValue}\n        aria-valuenow={value}\n        className={sliderClassNames}\n        tabIndex={0}>\n        <div className={trackClassNames} ref={this.setRenderedTrack}>\n          {trackContent}\n        </div>\n        {React.Children.map(children, child =>\n          React.cloneElement(child, { previewValue, isDragging, isPointerInside })\n        )}\n        <div\n          className={handleClassNames}\n          style={{ [isVertical ? verticalProp : horizontalProp]: toPercentString(displayValue, maxValue) }}\n          role=\"button\"\n          tabIndex={-1}\n          ref={this.setRenderedHandle}>\n          {handleContent}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Slider;\n\n/*\n\nConsider moving all events to track or slider itself. Or moving track on top of children!\n\n */\n\n/* Assumptions\n\nClickable area = track length OR is it slider length?\nIf track length - should we assume that it aligns with possible handle min/max positions?\n\n*/\n"]},"metadata":{},"sourceType":"script"}