{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.ControlledVideoStreamer = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _ControllerContext = _interopRequireDefault(require(\"./ControllerContext\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/*\nconst getObserver = (callback: HandleChangeMethod) => (key: string, value: any) => {\n  callback({ [key]: value });\n};\n*/\n\n\nconst registerObservers = (observe, keys, onChange) => keys.forEach(p => observe(p, onChange));\n\nconst connectControl = (Control, stateKeys) => {\n  // $FlowFixMe What's the best practices for extending component classes with static properties?\n  const resolvedStateKeys = stateKeys || Control.streamStateKeysForObservation || [];\n\n  if (!Array.isArray(resolvedStateKeys)) {\n    // Good old runtime check.\n    throw new Error(\"The component \".concat(Control.displayName || Control.name, \" cannot be connected to the player controller because no stream state property keys are specified to be observed.\"));\n  }\n\n  class Observer extends React.Component {\n    constructor(props) {\n      super(props);\n\n      _defineProperty(this, \"update\", prop => this.setState(prop));\n\n      const currentState = props.inspect();\n      const initialState = {};\n\n      if (currentState) {\n        resolvedStateKeys.forEach(key => initialState[key] = currentState[key]);\n      }\n\n      this.state = initialState;\n    }\n\n    componentWillUnmount() {\n      registerObservers(this.props.unobserve, resolvedStateKeys, this.update);\n    }\n\n    componentDidMount() {\n      registerObservers(this.props.observe, resolvedStateKeys, this.update);\n      const currentState = this.props.inspect();\n\n      if (currentState) {\n        resolvedStateKeys.forEach(key => this.setState({\n          [key]: currentState[key]\n        }));\n      }\n    }\n\n    render() {\n      return /*#__PURE__*/React.createElement(Control, _objectSpread({}, this.props.passdownProps, {}, this.state));\n    }\n\n  }\n\n  const ConnectedControl = props => /*#__PURE__*/React.createElement(_ControllerContext.default.Consumer, null, ({\n    observe,\n    unobserve,\n    setProperties,\n    inspect\n  }) => {\n    if (observe) {\n      return /*#__PURE__*/React.createElement(Observer, {\n        observe: observe,\n        unobserve: unobserve,\n        inspect: inspect,\n        passdownProps: _objectSpread({}, props, {\n          setProperties,\n          inspect\n        })\n      });\n    } else {\n      return /*#__PURE__*/React.createElement(Control, _objectSpread({}, props, {\n        setProperties,\n        inspect\n      }));\n    }\n  });\n\n  if (Control.displayName) {\n    ConnectedControl.displayName = 'Connected' + Control.displayName;\n  } else if (process.env.NODE_ENV === 'development') {\n    ConnectedControl.controlWithoutDisplayName = Control.name + ' wrapped in ConnectedControl';\n  } else {\n    ConnectedControl.displayName = 'Connected' + Control.name;\n  }\n\n  return ConnectedControl;\n};\n\nconst ControlledVideoStreamer = props => /*#__PURE__*/React.createElement(_ControllerContext.default.Consumer, null, ({\n  videoStreamer\n}) => videoStreamer != null ? React.cloneElement(videoStreamer, props) : null);\n\nexports.ControlledVideoStreamer = ControlledVideoStreamer;\nvar _default = connectControl;\nexports.default = _default;","map":{"version":3,"sources":["../../../src/replay/components/player/PlayerController/connectControl.js"],"names":["registerObservers","keys","p","observe","connectControl","resolvedStateKeys","stateKeys","Control","Array","React","constructor","currentState","props","initialState","key","prop","componentWillUnmount","componentDidMount","render","ConnectedControl","inspect","process","ControlledVideoStreamer","videoStreamer"],"mappings":"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","sourcesContent":["// @flow\nimport * as React from 'react';\nimport ControllerContext from './ControllerContext';\nimport type { InspectMethod, ObserveMethod, UnobserveMethod, SetPropertiesMethod } from './ControllerContext';\nimport type { VideoStreamState, VideoStreamStateKeys } from '../VideoStreamer/types';\nimport type { CommonGenericProps } from '../../common';\n\ntype HandleChangeMethod = ({ [VideoStreamStateKeys]: any }) => void;\n\ntype PassdownProps = VideoStreamState & {\n  setProperties?: SetPropertiesMethod,\n  inspect?: InspectMethod\n};\n\ntype ObserverProps = {\n  observe: ObserveMethod,\n  unobserve: UnobserveMethod,\n  inspect: InspectMethod,\n  passdownProps: PassdownProps\n};\n\n/*\nconst getObserver = (callback: HandleChangeMethod) => (key: string, value: any) => {\n  callback({ [key]: value });\n};\n*/\nconst registerObservers = (observe: ObserveMethod, keys: Array<VideoStreamStateKeys>, onChange: HandleChangeMethod) =>\n  keys.forEach(p => observe(p, onChange));\n\nconst connectControl = <Props: {}>(\n  Control: React.ComponentType<Props>,\n  stateKeys?: Array<VideoStreamStateKeys>\n): React.ComponentType<$Diff<Props, PassdownProps>> => {\n  // $FlowFixMe What's the best practices for extending component classes with static properties?\n  const resolvedStateKeys = stateKeys || Control.streamStateKeysForObservation || [];\n  if (!Array.isArray(resolvedStateKeys)) {\n    // Good old runtime check.\n    throw new Error(\n      `The component ${Control.displayName ||\n        Control.name} cannot be connected to the player controller because no stream state property keys are specified to be observed.`\n    );\n  }\n\n  class Observer extends React.Component<ObserverProps, any> {\n    constructor(props) {\n      super(props);\n      const currentState = props.inspect();\n      const initialState = {};\n      if (currentState) {\n        resolvedStateKeys.forEach(key => (initialState[key] = currentState[key]));\n      }\n      this.state = initialState;\n    }\n\n    update = prop => this.setState(prop);\n\n    componentWillUnmount() {\n      registerObservers(this.props.unobserve, resolvedStateKeys, this.update);\n    }\n\n    componentDidMount() {\n      registerObservers(this.props.observe, resolvedStateKeys, this.update);\n      const currentState = this.props.inspect();\n      if (currentState) {\n        resolvedStateKeys.forEach(key => this.setState({ [key]: currentState[key] }));\n      }\n    }\n\n    render() {\n      return <Control {...{ ...this.props.passdownProps, ...this.state }} />;\n    }\n  }\n\n  const ConnectedControl = (props: $Diff<Props, PassdownProps>) => (\n    <ControllerContext.Consumer>\n      {({ observe, unobserve, setProperties, inspect }) => {\n        if (observe) {\n          return (\n            <Observer\n              observe={observe}\n              unobserve={unobserve}\n              inspect={inspect}\n              passdownProps={{ ...props, setProperties, inspect }}\n            />\n          );\n        } else {\n          return <Control {...{ ...props, setProperties, inspect }} />;\n        }\n      }}\n    </ControllerContext.Consumer>\n  );\n\n  if (Control.displayName) {\n    ConnectedControl.displayName = 'Connected' + Control.displayName;\n  } else if (process.env.NODE_ENV === 'development') {\n    ConnectedControl.controlWithoutDisplayName = Control.name + ' wrapped in ConnectedControl';\n  } else {\n    ConnectedControl.displayName = 'Connected' + Control.name;\n  }\n  return ConnectedControl;\n};\n\nexport const ControlledVideoStreamer: React.StatelessFunctionalComponent<CommonGenericProps> = props => (\n  <ControllerContext.Consumer>\n    {({ videoStreamer }) => (videoStreamer != null ? React.cloneElement(videoStreamer, props) : null)}\n  </ControllerContext.Consumer>\n);\n\nexport default connectControl;\n"]},"metadata":{},"sourceType":"script"}