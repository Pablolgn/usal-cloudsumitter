{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _errorMapper = _interopRequireDefault(require(\"./errorMapper\"));\n\nvar _types = require(\"../types\");\n\nvar _common = require(\"../../../common\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst defaultPauseUpdateInterval = 5;\n\nfunction calculateBufferedAhead(videoElement) {\n  const currentTime = videoElement.currentTime;\n  const buffered = videoElement.buffered;\n  let ahead = 0;\n\n  for (let i = 0; i < buffered.length; ++i) {\n    if (buffered.start(i) - 2 <= currentTime && buffered.end(i) + 2 >= currentTime) {\n      ahead = buffered.end(i) - currentTime;\n      break;\n    }\n  }\n\n  return ahead;\n}\n\nconst getBasicVideoEventHandlers = ({\n  streamer,\n  videoElement,\n  streamRangeHelper,\n  configuration,\n  applyProperties,\n  updateStreamState,\n  log\n}) => {\n  const isSafariOrEdge = navigator.userAgent.indexOf('Edge') > 0 || navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') < 0 && navigator.userAgent.indexOf('Firefox') < 0;\n  let lifeCycleManager = {\n    setStage: _ => {},\n    getStage: () => {}\n  };\n\n  function isPipAvailable() {\n    return (// $FlowFixMe: Too exotic for React's HTML element typedefs.\n      document.pictureInPictureEnabled && !videoElement.disablePictureInPicture || // $FlowFixMe\n      videoElement.webkitSupportsPresentationMode && videoElement.webkitSupportsPresentationMode('picture-in-picture') && // $FlowFixMe\n      typeof videoElement.webkitSetPresentationMode === 'function' || false\n    );\n  }\n\n  function onError() {\n    const playbackError = (0, _errorMapper.default)(videoElement);\n\n    if (streamer.props.onPlaybackError) {\n      streamer.props.onPlaybackError(playbackError);\n    }\n\n    updateStreamState({\n      error: videoElement.error\n    });\n\n    if (playbackError.severity === 'FATAL') {\n      lifeCycleManager.setStage('dead');\n      updateStreamState({\n        playState: 'inactive',\n        isBuffering: false,\n        isSeeking: false\n      });\n    }\n\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function onLoadStart() {\n    log && log('loadstart');\n\n    if (lifeCycleManager.getStage() === 'new') {\n      lifeCycleManager.setStage('starting');\n\n      if (streamer.props.initialPlaybackProps) {\n        const _streamer$props$initi = streamer.props.initialPlaybackProps,\n              isMuted = _streamer$props$initi.isMuted,\n              volume = _streamer$props$initi.volume,\n              bitrateFix = _streamer$props$initi.bitrateFix,\n              bitrateCap = _streamer$props$initi.bitrateCap;\n        applyProperties({\n          isMuted,\n          volume,\n          bitrateFix: bitrateFix,\n          bitrateCap: bitrateCap\n        });\n      }\n\n      updateStreamState({\n        playState: 'starting',\n        isBuffering: true,\n        volume: videoElement.volume,\n        isMuted: videoElement.muted\n      });\n    }\n  }\n\n  function onLoadedMetadata() {\n    log && log('loadedmetadata');\n\n    if (streamer.props.initialPlaybackProps && streamer.props.initialPlaybackProps.isPaused) {\n      videoElement.pause();\n    }\n\n    updateStreamState(streamRangeHelper.calculateNewState());\n    updateStreamState({\n      isPipAvailable: isPipAvailable()\n    });\n  }\n\n  function onCanPlay() {\n    log && log('canplay'); // If starting as paused, we consider \"canplay\" as completed starting. The playState must be updated accordingly.\n    // When starting as playing, the starting to started transition is handled by the onPlaying handler.\n\n    const stage = lifeCycleManager.getStage();\n\n    if (stage === 'starting') {\n      if (streamer.props.initialPlaybackProps && streamer.props.initialPlaybackProps.isPaused) {\n        lifeCycleManager.setStage('started');\n      }\n    } else if (stage === 'started') {\n      updateStreamState({\n        isBuffering: false,\n        playState: videoElement.paused ? 'paused' : 'playing'\n      });\n    }\n\n    updateStreamState({\n      bufferedAhead: calculateBufferedAhead(videoElement),\n      isPipAvailable: isPipAvailable()\n    });\n\n    if (videoElement.paused) {\n      updateStreamState({\n        playState: 'paused',\n        isPaused: true,\n        isBuffering: false,\n        isSeeking: false\n      });\n      pauseStreamRangeUpdater.start();\n    }\n  }\n\n  function onWaiting() {\n    log && log('waiting');\n    updateStreamState({\n      isBuffering: true\n    });\n\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({\n        playState: 'buffering'\n      });\n    }\n  }\n\n  function onStalled() {\n    log && log('stalled'); // The stalled event is fired also after pausing in Safari.\n\n    if (!isSafariOrEdge) {\n      updateStreamState({\n        isBuffering: true\n      });\n\n      if (lifeCycleManager.getStage() === 'started') {\n        updateStreamState({\n          playState: 'buffering'\n        });\n      }\n    }\n  }\n\n  function onPlaying() {\n    log && log('playing'); // When this is invoked, and we are not starting as paused, we consider the playback as started.\n\n    if (lifeCycleManager.getStage() === 'starting') {\n      lifeCycleManager.setStage('started');\n    }\n\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({\n        playState: 'playing',\n        isBuffering: false,\n        isPaused: false,\n        isSeeking: false\n      });\n    }\n\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function onPause() {\n    log && log('pause');\n\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({\n        playState: 'paused',\n        isPaused: true\n      });\n    }\n\n    pauseStreamRangeUpdater.start();\n  }\n\n  function onSeeking() {\n    log && log('seeking');\n    pauseStreamRangeUpdater.stop();\n\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({\n        playState: 'seeking',\n        isSeeking: true\n      });\n    }\n  }\n\n  function onSeeked() {\n    log && log('seeked');\n\n    if (isSafariOrEdge) {\n      if (videoElement.paused) {\n        updateStreamState({\n          playState: 'paused',\n          isPaused: true,\n          isBuffering: false,\n          isSeeking: false\n        });\n        pauseStreamRangeUpdater.start();\n      } else {\n        updateStreamState({\n          playState: 'playing',\n          isPaused: false,\n          isBuffering: false,\n          isSeeking: false\n        });\n        pauseStreamRangeUpdater.stop();\n      }\n    }\n  }\n\n  function onDurationChange() {\n    log && log('durationchange');\n    updateStreamState(streamRangeHelper.calculateNewState());\n  }\n\n  function onTimeUpdate() {\n    updateStreamState(streamRangeHelper.calculateNewState());\n  }\n\n  function onVolumeChange() {\n    log && log('volumechange');\n    updateStreamState({\n      volume: videoElement.volume,\n      isMuted: videoElement.muted\n    });\n  }\n\n  function onProgress() {\n    updateStreamState({\n      bufferedAhead: calculateBufferedAhead(videoElement)\n    });\n  }\n\n  function onEnded() {\n    log && log('ended');\n\n    if (lifeCycleManager.getStage() === 'started') {\n      //lifeCycleManager.setStage('ended');\n      updateStreamState({\n        playState: 'inactive'\n      });\n    }\n\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function handleEnterPictureInPicture() {\n    updateStreamState({\n      isPipActive: true\n    });\n  }\n\n  function handleLeavePictureInPicture() {\n    updateStreamState({\n      isPipActive: false\n    });\n  } // START Ugly Safari custom events and properties section\n\n\n  function handlePlaybackTargetAvailabilityChanged(evt) {\n    if (evt.availability === 'available') {\n      updateStreamState({\n        isAirPlayAvailable: true\n      });\n    } else {\n      updateStreamState({\n        isAirPlayAvailable: false\n      });\n    }\n  }\n\n  function handleCurrentPlaybackTargetIsWirelessChanged(evt) {\n    // We don't know the current state, and need to guess based on a toggle.\n    // $FlowFixMe: Typedefs not up-to-date.\n    updateStreamState({\n      isAirPlayActive: videoElement.webkitCurrentPlaybackTargetIsWireless\n    });\n  }\n\n  function handlePresentationModeChanged() {\n    // $FlowFixMe: Too exotic for Safari typedefs.\n    if (videoElement.webkitPresentationMode === 'picture-in-picture') {\n      updateStreamState({\n        isPipActive: true\n      });\n    } else {\n      updateStreamState({\n        isPipActive: false\n      });\n    }\n  } // END Ugly Safari custom events and properties section\n\n\n  function onPauseInterval() {\n    streamRangeHelper.adjustForDvrStartOffset();\n    updateStreamState(streamRangeHelper.calculateNewState());\n  }\n\n  function setLifeCycleManager(manager) {\n    lifeCycleManager = manager;\n  }\n\n  const pauseStreamRangeUpdater = (0, _common.getIntervalRunner)(onPauseInterval, configuration && configuration.pauseUpdateInterval || defaultPauseUpdateInterval);\n  videoElement.addEventListener('enterpictureinpicture', handleEnterPictureInPicture);\n  videoElement.addEventListener('leavepictureinpicture', handleLeavePictureInPicture);\n  videoElement.addEventListener('webkitcurrentplaybacktargetiswirelesschanged', handleCurrentPlaybackTargetIsWirelessChanged); // $FlowFixMe: evt.availability is unknown to React.\n\n  videoElement.addEventListener('webkitplaybacktargetavailabilitychanged', handlePlaybackTargetAvailabilityChanged);\n  videoElement.addEventListener('webkitpresentationmodechanged', handlePresentationModeChanged);\n\n  function cleanup() {\n    videoElement.removeEventListener('enterpictureinpicture', handleEnterPictureInPicture);\n    videoElement.removeEventListener('leavepictureinpicture', handleLeavePictureInPicture);\n    videoElement.removeEventListener('webkitcurrentplaybacktargetiswirelesschanged', handleCurrentPlaybackTargetIsWirelessChanged); // $FlowFixMe: evt.availability is unknown to React.\n\n    videoElement.removeEventListener('webkitplaybacktargetavailabilitychanged', handlePlaybackTargetAvailabilityChanged);\n    videoElement.removeEventListener('webkitpresentationmodechanged', handlePresentationModeChanged);\n  }\n\n  return {\n    videoElementEventHandlers: {\n      onLoadStart,\n      onLoadedMetadata,\n      onCanPlay,\n      onWaiting,\n      onStalled,\n      onPlaying,\n      onPause,\n      onSeeking,\n      onSeeked,\n      onDurationChange,\n      onTimeUpdate,\n      onVolumeChange,\n      onProgress,\n      onError,\n      onEnded\n    },\n    pauseStreamRangeUpdater,\n    setLifeCycleManager,\n    isPipAvailable,\n    cleanup\n  };\n};\n\nvar _default = getBasicVideoEventHandlers;\nexports.default = _default;","map":{"version":3,"sources":["../../../../src/replay/components/player/VideoStreamer/BasicVideoStreamer/basicVideoEventHandlers.js"],"names":["defaultPauseUpdateInterval","currentTime","videoElement","buffered","ahead","i","getBasicVideoEventHandlers","log","isSafariOrEdge","navigator","lifeCycleManager","setStage","_","getStage","document","playbackError","streamer","updateStreamState","error","playState","isBuffering","isSeeking","pauseStreamRangeUpdater","isMuted","volume","bitrateFix","bitrateCap","applyProperties","muted","streamRangeHelper","isPipAvailable","stage","bufferedAhead","calculateBufferedAhead","isPaused","isPipActive","evt","isAirPlayAvailable","isAirPlayActive","webkitCurrentPlaybackTargetIsWireless","configuration","videoElementEventHandlers","onEnded","cleanup"],"mappings":";;;;;;;AACA,IAAA,YAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AAGA,IAAA,MAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;;;;;;;AAEA,MAAMA,0BAA0B,GAAhC,CAAA;;AAEA,SAAA,sBAAA,CAAA,YAAA,EAAwE;AACtE,QAAMC,WAAW,GAAGC,YAAY,CAAhC,WAAA;AACA,QAAMC,QAAQ,GAAGD,YAAY,CAA7B,QAAA;AACA,MAAIE,KAAK,GAAT,CAAA;;AAEA,OAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGF,QAAQ,CAA5B,MAAA,EAAqC,EAArC,CAAA,EAA0C;AACxC,QAAIA,QAAQ,CAARA,KAAAA,CAAAA,CAAAA,IAAAA,CAAAA,IAAAA,WAAAA,IAAwCA,QAAQ,CAARA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,IAA5C,WAAA,EAAgF;AAC9EC,MAAAA,KAAK,GAAGD,QAAQ,CAARA,GAAAA,CAAAA,CAAAA,IAARC,WAAAA;AACA;AACD;AACF;;AACD,SAAA,KAAA;AACD;;AAQD,MAAME,0BAA0B,GAAG,CAAkC;AAAA,EAAA,QAAA;AAAA,EAAA,YAAA;AAAA,EAAA,iBAAA;AAAA,EAAA,aAAA;AAAA,EAAA,eAAA;AAAA,EAAA,iBAAA;AAOnEC,EAAAA;AAPmE,CAAlC,KAkB7B;AACJ,QAAMC,cAAc,GAClBC,SAAS,CAATA,SAAAA,CAAAA,OAAAA,CAAAA,MAAAA,IAAAA,CAAAA,IACCA,SAAS,CAATA,SAAAA,CAAAA,OAAAA,CAAAA,QAAAA,IAAAA,CAAAA,IACCA,SAAS,CAATA,SAAAA,CAAAA,OAAAA,CAAAA,QAAAA,IADDA,CAAAA,IAECA,SAAS,CAATA,SAAAA,CAAAA,OAAAA,CAAAA,SAAAA,IAJJ,CAAA;AAMA,MAAIC,gBAAgB,GAAG;AACrBC,IAAAA,QAAQ,EAAGC,CAAD,IAA0B,CADf,CAAA;AAErBC,IAAAA,QAAQ,EAAE,MAAM,CAAE;AAFG,GAAvB;;AAKA,WAAA,cAAA,GAA0B;AACxB,WACE;AACCC,MAAAA,QAAQ,CAARA,uBAAAA,IAAoC,CAACZ,YAAY,CAAlD,uBAACY,IAA8E;AAC9EZ,MAAAA,YAAY,CAAZA,8BAAAA,IACDA,YAAY,CAAZA,8BAAAA,CADCA,oBACDA,CADCA,IACoE;AACnE,aAAOA,YAAY,CAAnB,yBAAA,KAHF,UAACY,IAID;AANF;AAQD;;AAED,WAAA,OAAA,GAAmB;AACjB,UAAMC,aAAa,GAAG,CAAA,GAAA,YAAA,CAAA,OAAA,EAAtB,YAAsB,CAAtB;;AACA,QAAIC,QAAQ,CAARA,KAAAA,CAAJ,eAAA,EAAoC;AAClCA,MAAAA,QAAQ,CAARA,KAAAA,CAAAA,eAAAA,CAAAA,aAAAA;AACD;;AACDC,IAAAA,iBAAiB,CAAC;AAAEC,MAAAA,KAAK,EAAEhB,YAAY,CAACgB;AAAtB,KAAD,CAAjBD;;AACA,QAAIF,aAAa,CAAbA,QAAAA,KAAJ,OAAA,EAAwC;AACtCL,MAAAA,gBAAgB,CAAhBA,QAAAA,CAAAA,MAAAA;AACAO,MAAAA,iBAAiB,CAAC;AAAEE,QAAAA,SAAS,EAAX,UAAA;AAAyBC,QAAAA,WAAW,EAApC,KAAA;AAA6CC,QAAAA,SAAS,EAAE;AAAxD,OAAD,CAAjBJ;AACD;;AACDK,IAAAA,uBAAuB,CAAvBA,IAAAA;AACD;;AAED,WAAA,WAAA,GAAuB;AACrBf,IAAAA,GAAG,IAAIA,GAAG,CAAVA,WAAU,CAAVA;;AACA,QAAIG,gBAAgB,CAAhBA,QAAAA,OAAJ,KAAA,EAA2C;AACzCA,MAAAA,gBAAgB,CAAhBA,QAAAA,CAAAA,UAAAA;;AACA,UAAIM,QAAQ,CAARA,KAAAA,CAAJ,oBAAA,EAAyC;AAAA,cAAA,qBAAA,GACaA,QAAQ,CAARA,KAAAA,CADb,oBAAA;AAAA,cAC/BO,OAD+B,GAAA,qBAAA,CAAA,OAAA;AAAA,cACtBC,MADsB,GAAA,qBAAA,CAAA,MAAA;AAAA,cACdC,UADc,GAAA,qBAAA,CAAA,UAAA;AAAA,cACFC,UADE,GAAA,qBAAA,CAAA,UAAA;AAEvCC,QAAAA,eAAe,CAAC;AAAA,UAAA,OAAA;AAAA,UAAA,MAAA;AAAmBF,UAAAA,UAAU,EAA7B,UAAA;AAA2CC,UAAAA,UAAU,EAAEA;AAAvD,SAAD,CAAfC;AACD;;AACDV,MAAAA,iBAAiB,CAAC;AAChBE,QAAAA,SAAS,EADO,UAAA;AAEhBC,QAAAA,WAAW,EAFK,IAAA;AAGhBI,QAAAA,MAAM,EAAEtB,YAAY,CAHJ,MAAA;AAIhBqB,QAAAA,OAAO,EAAErB,YAAY,CAAC0B;AAJN,OAAD,CAAjBX;AAMD;AACF;;AAED,WAAA,gBAAA,GAA4B;AAC1BV,IAAAA,GAAG,IAAIA,GAAG,CAAVA,gBAAU,CAAVA;;AACA,QAAIS,QAAQ,CAARA,KAAAA,CAAAA,oBAAAA,IAAuCA,QAAQ,CAARA,KAAAA,CAAAA,oBAAAA,CAA3C,QAAA,EAAyF;AACvFd,MAAAA,YAAY,CAAZA,KAAAA;AACD;;AACDe,IAAAA,iBAAiB,CAACY,iBAAiB,CAAnCZ,iBAAkBY,EAAD,CAAjBZ;AACAA,IAAAA,iBAAiB,CAAC;AAChBa,MAAAA,cAAc,EAAEA,cAAc;AADd,KAAD,CAAjBb;AAGD;;AAED,WAAA,SAAA,GAAqB;AACnBV,IAAAA,GAAG,IAAIA,GAAG,CADS,SACT,CAAVA,CADmB,CAEnB;AACA;;AACA,UAAMwB,KAAK,GAAGrB,gBAAgB,CAA9B,QAAcA,EAAd;;AACA,QAAIqB,KAAK,KAAT,UAAA,EAA0B;AACxB,UAAIf,QAAQ,CAARA,KAAAA,CAAAA,oBAAAA,IAAuCA,QAAQ,CAARA,KAAAA,CAAAA,oBAAAA,CAA3C,QAAA,EAAyF;AACvFN,QAAAA,gBAAgB,CAAhBA,QAAAA,CAAAA,SAAAA;AACD;AAHH,KAAA,MAIO,IAAIqB,KAAK,KAAT,SAAA,EAAyB;AAC9Bd,MAAAA,iBAAiB,CAAC;AAAEG,QAAAA,WAAW,EAAb,KAAA;AAAsBD,QAAAA,SAAS,EAAEjB,YAAY,CAAZA,MAAAA,GAAAA,QAAAA,GAAiC;AAAlE,OAAD,CAAjBe;AACD;;AACDA,IAAAA,iBAAiB,CAAC;AAChBe,MAAAA,aAAa,EAAEC,sBAAsB,CADrB,YACqB,CADrB;AAEhBH,MAAAA,cAAc,EAAEA,cAAc;AAFd,KAAD,CAAjBb;;AAKA,QAAIf,YAAY,CAAhB,MAAA,EAAyB;AACvBe,MAAAA,iBAAiB,CAAC;AAAEE,QAAAA,SAAS,EAAX,QAAA;AAAuBe,QAAAA,QAAQ,EAA/B,IAAA;AAAuCd,QAAAA,WAAW,EAAlD,KAAA;AAA2DC,QAAAA,SAAS,EAAE;AAAtE,OAAD,CAAjBJ;AACAK,MAAAA,uBAAuB,CAAvBA,KAAAA;AACD;AACF;;AAED,WAAA,SAAA,GAAqB;AACnBf,IAAAA,GAAG,IAAIA,GAAG,CAAVA,SAAU,CAAVA;AACAU,IAAAA,iBAAiB,CAAC;AAAEG,MAAAA,WAAW,EAAE;AAAf,KAAD,CAAjBH;;AACA,QAAIP,gBAAgB,CAAhBA,QAAAA,OAAJ,SAAA,EAA+C;AAC7CO,MAAAA,iBAAiB,CAAC;AAAEE,QAAAA,SAAS,EAAE;AAAb,OAAD,CAAjBF;AACD;AACF;;AAED,WAAA,SAAA,GAAqB;AACnBV,IAAAA,GAAG,IAAIA,GAAG,CADS,SACT,CAAVA,CADmB,CAEnB;;AACA,QAAI,CAAJ,cAAA,EAAqB;AACnBU,MAAAA,iBAAiB,CAAC;AAAEG,QAAAA,WAAW,EAAE;AAAf,OAAD,CAAjBH;;AACA,UAAIP,gBAAgB,CAAhBA,QAAAA,OAAJ,SAAA,EAA+C;AAC7CO,QAAAA,iBAAiB,CAAC;AAAEE,UAAAA,SAAS,EAAE;AAAb,SAAD,CAAjBF;AACD;AACF;AACF;;AAED,WAAA,SAAA,GAAqB;AACnBV,IAAAA,GAAG,IAAIA,GAAG,CADS,SACT,CAAVA,CADmB,CAEnB;;AACA,QAAIG,gBAAgB,CAAhBA,QAAAA,OAAJ,UAAA,EAAgD;AAC9CA,MAAAA,gBAAgB,CAAhBA,QAAAA,CAAAA,SAAAA;AACD;;AACD,QAAIA,gBAAgB,CAAhBA,QAAAA,OAAJ,SAAA,EAA+C;AAC7CO,MAAAA,iBAAiB,CAAC;AAAEE,QAAAA,SAAS,EAAX,SAAA;AAAwBC,QAAAA,WAAW,EAAnC,KAAA;AAA4Cc,QAAAA,QAAQ,EAApD,KAAA;AAA6Db,QAAAA,SAAS,EAAE;AAAxE,OAAD,CAAjBJ;AACD;;AACDK,IAAAA,uBAAuB,CAAvBA,IAAAA;AACD;;AAED,WAAA,OAAA,GAAmB;AACjBf,IAAAA,GAAG,IAAIA,GAAG,CAAVA,OAAU,CAAVA;;AACA,QAAIG,gBAAgB,CAAhBA,QAAAA,OAAJ,SAAA,EAA+C;AAC7CO,MAAAA,iBAAiB,CAAC;AAAEE,QAAAA,SAAS,EAAX,QAAA;AAAuBe,QAAAA,QAAQ,EAAE;AAAjC,OAAD,CAAjBjB;AACD;;AACDK,IAAAA,uBAAuB,CAAvBA,KAAAA;AACD;;AAED,WAAA,SAAA,GAAqB;AACnBf,IAAAA,GAAG,IAAIA,GAAG,CAAVA,SAAU,CAAVA;AACAe,IAAAA,uBAAuB,CAAvBA,IAAAA;;AACA,QAAIZ,gBAAgB,CAAhBA,QAAAA,OAAJ,SAAA,EAA+C;AAC7CO,MAAAA,iBAAiB,CAAC;AAAEE,QAAAA,SAAS,EAAX,SAAA;AAAwBE,QAAAA,SAAS,EAAE;AAAnC,OAAD,CAAjBJ;AACD;AACF;;AAED,WAAA,QAAA,GAAoB;AAClBV,IAAAA,GAAG,IAAIA,GAAG,CAAVA,QAAU,CAAVA;;AACA,QAAA,cAAA,EAAoB;AAClB,UAAIL,YAAY,CAAhB,MAAA,EAAyB;AACvBe,QAAAA,iBAAiB,CAAC;AAAEE,UAAAA,SAAS,EAAX,QAAA;AAAuBe,UAAAA,QAAQ,EAA/B,IAAA;AAAuCd,UAAAA,WAAW,EAAlD,KAAA;AAA2DC,UAAAA,SAAS,EAAE;AAAtE,SAAD,CAAjBJ;AACAK,QAAAA,uBAAuB,CAAvBA,KAAAA;AAFF,OAAA,MAGO;AACLL,QAAAA,iBAAiB,CAAC;AAAEE,UAAAA,SAAS,EAAX,SAAA;AAAwBe,UAAAA,QAAQ,EAAhC,KAAA;AAAyCd,UAAAA,WAAW,EAApD,KAAA;AAA6DC,UAAAA,SAAS,EAAE;AAAxE,SAAD,CAAjBJ;AACAK,QAAAA,uBAAuB,CAAvBA,IAAAA;AACD;AACF;AACF;;AAED,WAAA,gBAAA,GAA4B;AAC1Bf,IAAAA,GAAG,IAAIA,GAAG,CAAVA,gBAAU,CAAVA;AACAU,IAAAA,iBAAiB,CAACY,iBAAiB,CAAnCZ,iBAAkBY,EAAD,CAAjBZ;AACD;;AAED,WAAA,YAAA,GAAwB;AACtBA,IAAAA,iBAAiB,CAACY,iBAAiB,CAAnCZ,iBAAkBY,EAAD,CAAjBZ;AACD;;AAED,WAAA,cAAA,GAA0B;AACxBV,IAAAA,GAAG,IAAIA,GAAG,CAAVA,cAAU,CAAVA;AACAU,IAAAA,iBAAiB,CAAC;AAAEO,MAAAA,MAAM,EAAEtB,YAAY,CAAtB,MAAA;AAA+BqB,MAAAA,OAAO,EAAErB,YAAY,CAAC0B;AAArD,KAAD,CAAjBX;AACD;;AAED,WAAA,UAAA,GAAsB;AACpBA,IAAAA,iBAAiB,CAAC;AAAEe,MAAAA,aAAa,EAAEC,sBAAsB,CAAA,YAAA;AAAvC,KAAD,CAAjBhB;AACD;;AAED,WAAA,OAAA,GAAmB;AACjBV,IAAAA,GAAG,IAAIA,GAAG,CAAVA,OAAU,CAAVA;;AACA,QAAIG,gBAAgB,CAAhBA,QAAAA,OAAJ,SAAA,EAA+C;AAC7C;AACAO,MAAAA,iBAAiB,CAAC;AAAEE,QAAAA,SAAS,EAAE;AAAb,OAAD,CAAjBF;AACD;;AACDK,IAAAA,uBAAuB,CAAvBA,IAAAA;AACD;;AAED,WAAA,2BAAA,GAAuC;AACrCL,IAAAA,iBAAiB,CAAC;AAAEkB,MAAAA,WAAW,EAAE;AAAf,KAAD,CAAjBlB;AACD;;AAED,WAAA,2BAAA,GAAuC;AACrCA,IAAAA,iBAAiB,CAAC;AAAEkB,MAAAA,WAAW,EAAE;AAAf,KAAD,CAAjBlB;AAnLE,GAAA,CAsLJ;;;AAEA,WAAA,uCAAA,CAAA,GAAA,EAAuG;AACrG,QAAImB,GAAG,CAAHA,YAAAA,KAAJ,WAAA,EAAsC;AACpCnB,MAAAA,iBAAiB,CAAC;AAAEoB,QAAAA,kBAAkB,EAAE;AAAtB,OAAD,CAAjBpB;AADF,KAAA,MAEO;AACLA,MAAAA,iBAAiB,CAAC;AAAEoB,QAAAA,kBAAkB,EAAE;AAAtB,OAAD,CAAjBpB;AACD;AACF;;AAED,WAAA,4CAAA,CAAA,GAAA,EAA2D;AACzD;AACA;AACAA,IAAAA,iBAAiB,CAAC;AAAEqB,MAAAA,eAAe,EAAEpC,YAAY,CAACqC;AAAhC,KAAD,CAAjBtB;AACD;;AAED,WAAA,6BAAA,GAAyC;AACvC;AACA,QAAIf,YAAY,CAAZA,sBAAAA,KAAJ,oBAAA,EAAkE;AAChEe,MAAAA,iBAAiB,CAAC;AAAEkB,QAAAA,WAAW,EAAE;AAAf,OAAD,CAAjBlB;AADF,KAAA,MAEO;AACLA,MAAAA,iBAAiB,CAAC;AAAEkB,QAAAA,WAAW,EAAE;AAAf,OAAD,CAAjBlB;AACD;AA5MC,GAAA,CA+MJ;;;AAEA,WAAA,eAAA,GAA2B;AACzBY,IAAAA,iBAAiB,CAAjBA,uBAAAA;AACAZ,IAAAA,iBAAiB,CAACY,iBAAiB,CAAnCZ,iBAAkBY,EAAD,CAAjBZ;AACD;;AAED,WAAA,mBAAA,CAAA,OAAA,EAAkH;AAChHP,IAAAA,gBAAgB,GAAhBA,OAAAA;AACD;;AAED,QAAMY,uBAAuB,GAAG,CAAA,GAAA,OAAA,CAAA,iBAAA,EAAA,eAAA,EAE7BkB,aAAa,IAAIA,aAAa,CAA/B,mBAACA,IAFH,0BAAgC,CAAhC;AAKAtC,EAAAA,YAAY,CAAZA,gBAAAA,CAAAA,uBAAAA,EAAAA,2BAAAA;AACAA,EAAAA,YAAY,CAAZA,gBAAAA,CAAAA,uBAAAA,EAAAA,2BAAAA;AACAA,EAAAA,YAAY,CAAZA,gBAAAA,CAAAA,8CAAAA,EAjOI,4CAiOJA,EAjOI,CAqOJ;;AACAA,EAAAA,YAAY,CAAZA,gBAAAA,CAAAA,yCAAAA,EAAAA,uCAAAA;AACAA,EAAAA,YAAY,CAAZA,gBAAAA,CAAAA,+BAAAA,EAAAA,6BAAAA;;AAEA,WAAA,OAAA,GAAmB;AACjBA,IAAAA,YAAY,CAAZA,mBAAAA,CAAAA,uBAAAA,EAAAA,2BAAAA;AACAA,IAAAA,YAAY,CAAZA,mBAAAA,CAAAA,uBAAAA,EAAAA,2BAAAA;AACAA,IAAAA,YAAY,CAAZA,mBAAAA,CAAAA,8CAAAA,EAHiB,4CAGjBA,EAHiB,CAOjB;;AACAA,IAAAA,YAAY,CAAZA,mBAAAA,CAAAA,yCAAAA,EAAAA,uCAAAA;AAIAA,IAAAA,YAAY,CAAZA,mBAAAA,CAAAA,+BAAAA,EAAAA,6BAAAA;AACD;;AAED,SAAO;AACLuC,IAAAA,yBAAyB,EAAE;AAAA,MAAA,WAAA;AAAA,MAAA,gBAAA;AAAA,MAAA,SAAA;AAAA,MAAA,SAAA;AAAA,MAAA,SAAA;AAAA,MAAA,SAAA;AAAA,MAAA,OAAA;AAAA,MAAA,SAAA;AAAA,MAAA,QAAA;AAAA,MAAA,gBAAA;AAAA,MAAA,YAAA;AAAA,MAAA,cAAA;AAAA,MAAA,UAAA;AAAA,MAAA,OAAA;AAezBC,MAAAA;AAfyB,KADtB;AAAA,IAAA,uBAAA;AAAA,IAAA,mBAAA;AAAA,IAAA,cAAA;AAqBLC,IAAAA;AArBK,GAAP;AA1QF,CAAA;;eAmSerC,0B","sourcesContent":["// @flow\nimport mapError from './errorMapper';\nimport type { InitialPlaybackProps, PlaybackProps, PlaybackSource, VideoStreamState } from '../types';\nimport type { PlaybackLifeCycle, StreamRangeHelper } from '../common/types';\nimport { PlaybackError } from '../types';\nimport { getIntervalRunner } from '../../../common';\n\nconst defaultPauseUpdateInterval = 5;\n\nfunction calculateBufferedAhead(videoElement: HTMLVideoElement): number {\n  const currentTime = videoElement.currentTime;\n  const buffered = videoElement.buffered;\n  let ahead = 0;\n\n  for (let i = 0; i < buffered.length; ++i) {\n    if (buffered.start(i) - 2 <= currentTime && buffered.end(i) + 2 >= currentTime) {\n      ahead = buffered.end(i) - currentTime;\n      break;\n    }\n  }\n  return ahead;\n}\n\nexport type BasicVideoEventHandlersProps = {\n  onPlaybackError?: PlaybackError => void,\n  initialPlaybackProps?: InitialPlaybackProps,\n  source?: ?PlaybackSource\n};\n\nconst getBasicVideoEventHandlers = <P: BasicVideoEventHandlersProps>({\n  streamer,\n  videoElement,\n  streamRangeHelper,\n  configuration,\n  applyProperties,\n  updateStreamState,\n  log\n}: {\n  streamer: {\n    props: P\n  },\n  videoElement: HTMLVideoElement,\n  streamRangeHelper: StreamRangeHelper,\n  configuration: ?{ pauseUpdateInterval?: ?number },\n  applyProperties: PlaybackProps => void,\n  updateStreamState: VideoStreamState => void,\n  log?: string => void\n}) => {\n  const isSafariOrEdge =\n    navigator.userAgent.indexOf('Edge') > 0 ||\n    (navigator.userAgent.indexOf('Safari') > 0 &&\n      navigator.userAgent.indexOf('Chrome') < 0 &&\n      navigator.userAgent.indexOf('Firefox') < 0);\n\n  let lifeCycleManager = {\n    setStage: (_: PlaybackLifeCycle) => {},\n    getStage: () => {}\n  };\n\n  function isPipAvailable() {\n    return (\n      // $FlowFixMe: Too exotic for React's HTML element typedefs.\n      (document.pictureInPictureEnabled && !videoElement.disablePictureInPicture) || // $FlowFixMe\n      (videoElement.webkitSupportsPresentationMode &&\n      videoElement.webkitSupportsPresentationMode('picture-in-picture') && // $FlowFixMe\n        typeof videoElement.webkitSetPresentationMode === 'function') ||\n      false\n    );\n  }\n\n  function onError() {\n    const playbackError = mapError(videoElement);\n    if (streamer.props.onPlaybackError) {\n      streamer.props.onPlaybackError(playbackError);\n    }\n    updateStreamState({ error: videoElement.error });\n    if (playbackError.severity === 'FATAL') {\n      lifeCycleManager.setStage('dead');\n      updateStreamState({ playState: 'inactive', isBuffering: false, isSeeking: false });\n    }\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function onLoadStart() {\n    log && log('loadstart');\n    if (lifeCycleManager.getStage() === 'new') {\n      lifeCycleManager.setStage('starting');\n      if (streamer.props.initialPlaybackProps) {\n        const { isMuted, volume, bitrateFix, bitrateCap } = streamer.props.initialPlaybackProps;\n        applyProperties({ isMuted, volume, bitrateFix: bitrateFix, bitrateCap: bitrateCap });\n      }\n      updateStreamState({\n        playState: 'starting',\n        isBuffering: true,\n        volume: videoElement.volume,\n        isMuted: videoElement.muted\n      });\n    }\n  }\n\n  function onLoadedMetadata() {\n    log && log('loadedmetadata');\n    if (streamer.props.initialPlaybackProps && streamer.props.initialPlaybackProps.isPaused) {\n      videoElement.pause();\n    }\n    updateStreamState(streamRangeHelper.calculateNewState());\n    updateStreamState({\n      isPipAvailable: isPipAvailable()\n    });\n  }\n\n  function onCanPlay() {\n    log && log('canplay');\n    // If starting as paused, we consider \"canplay\" as completed starting. The playState must be updated accordingly.\n    // When starting as playing, the starting to started transition is handled by the onPlaying handler.\n    const stage = lifeCycleManager.getStage();\n    if (stage === 'starting') {\n      if (streamer.props.initialPlaybackProps && streamer.props.initialPlaybackProps.isPaused) {\n        lifeCycleManager.setStage('started');\n      }\n    } else if (stage === 'started') {\n      updateStreamState({ isBuffering: false, playState: videoElement.paused ? 'paused' : 'playing' });\n    }\n    updateStreamState({\n      bufferedAhead: calculateBufferedAhead(videoElement),\n      isPipAvailable: isPipAvailable()\n    });\n\n    if (videoElement.paused) {\n      updateStreamState({ playState: 'paused', isPaused: true, isBuffering: false, isSeeking: false });\n      pauseStreamRangeUpdater.start();\n    }\n  }\n\n  function onWaiting() {\n    log && log('waiting');\n    updateStreamState({ isBuffering: true });\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({ playState: 'buffering' });\n    }\n  }\n\n  function onStalled() {\n    log && log('stalled');\n    // The stalled event is fired also after pausing in Safari.\n    if (!isSafariOrEdge) {\n      updateStreamState({ isBuffering: true });\n      if (lifeCycleManager.getStage() === 'started') {\n        updateStreamState({ playState: 'buffering' });\n      }\n    }\n  }\n\n  function onPlaying() {\n    log && log('playing');\n    // When this is invoked, and we are not starting as paused, we consider the playback as started.\n    if (lifeCycleManager.getStage() === 'starting') {\n      lifeCycleManager.setStage('started');\n    }\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({ playState: 'playing', isBuffering: false, isPaused: false, isSeeking: false });\n    }\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function onPause() {\n    log && log('pause');\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({ playState: 'paused', isPaused: true });\n    }\n    pauseStreamRangeUpdater.start();\n  }\n\n  function onSeeking() {\n    log && log('seeking');\n    pauseStreamRangeUpdater.stop();\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({ playState: 'seeking', isSeeking: true });\n    }\n  }\n\n  function onSeeked() {\n    log && log('seeked');\n    if (isSafariOrEdge) {\n      if (videoElement.paused) {\n        updateStreamState({ playState: 'paused', isPaused: true, isBuffering: false, isSeeking: false });\n        pauseStreamRangeUpdater.start();\n      } else {\n        updateStreamState({ playState: 'playing', isPaused: false, isBuffering: false, isSeeking: false });\n        pauseStreamRangeUpdater.stop();\n      }\n    }\n  }\n\n  function onDurationChange() {\n    log && log('durationchange');\n    updateStreamState(streamRangeHelper.calculateNewState());\n  }\n\n  function onTimeUpdate() {\n    updateStreamState(streamRangeHelper.calculateNewState());\n  }\n\n  function onVolumeChange() {\n    log && log('volumechange');\n    updateStreamState({ volume: videoElement.volume, isMuted: videoElement.muted });\n  }\n\n  function onProgress() {\n    updateStreamState({ bufferedAhead: calculateBufferedAhead(videoElement) });\n  }\n\n  function onEnded() {\n    log && log('ended');\n    if (lifeCycleManager.getStage() === 'started') {\n      //lifeCycleManager.setStage('ended');\n      updateStreamState({ playState: 'inactive' });\n    }\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function handleEnterPictureInPicture() {\n    updateStreamState({ isPipActive: true });\n  }\n\n  function handleLeavePictureInPicture() {\n    updateStreamState({ isPipActive: false });\n  }\n\n  // START Ugly Safari custom events and properties section\n\n  function handlePlaybackTargetAvailabilityChanged(evt: { availability: 'available' | 'not-available' }) {\n    if (evt.availability === 'available') {\n      updateStreamState({ isAirPlayAvailable: true });\n    } else {\n      updateStreamState({ isAirPlayAvailable: false });\n    }\n  }\n\n  function handleCurrentPlaybackTargetIsWirelessChanged(evt) {\n    // We don't know the current state, and need to guess based on a toggle.\n    // $FlowFixMe: Typedefs not up-to-date.\n    updateStreamState({ isAirPlayActive: videoElement.webkitCurrentPlaybackTargetIsWireless });\n  }\n\n  function handlePresentationModeChanged() {\n    // $FlowFixMe: Too exotic for Safari typedefs.\n    if (videoElement.webkitPresentationMode === 'picture-in-picture') {\n      updateStreamState({ isPipActive: true });\n    } else {\n      updateStreamState({ isPipActive: false });\n    }\n  }\n\n  // END Ugly Safari custom events and properties section\n\n  function onPauseInterval() {\n    streamRangeHelper.adjustForDvrStartOffset();\n    updateStreamState(streamRangeHelper.calculateNewState());\n  }\n\n  function setLifeCycleManager(manager: { setStage: PlaybackLifeCycle => void, getStage: () => PlaybackLifeCycle }) {\n    lifeCycleManager = manager;\n  }\n\n  const pauseStreamRangeUpdater = getIntervalRunner(\n    onPauseInterval,\n    (configuration && configuration.pauseUpdateInterval) || defaultPauseUpdateInterval\n  );\n\n  videoElement.addEventListener('enterpictureinpicture', handleEnterPictureInPicture);\n  videoElement.addEventListener('leavepictureinpicture', handleLeavePictureInPicture);\n  videoElement.addEventListener(\n    'webkitcurrentplaybacktargetiswirelesschanged',\n    handleCurrentPlaybackTargetIsWirelessChanged\n  );\n  // $FlowFixMe: evt.availability is unknown to React.\n  videoElement.addEventListener('webkitplaybacktargetavailabilitychanged', handlePlaybackTargetAvailabilityChanged);\n  videoElement.addEventListener('webkitpresentationmodechanged', handlePresentationModeChanged);\n\n  function cleanup() {\n    videoElement.removeEventListener('enterpictureinpicture', handleEnterPictureInPicture);\n    videoElement.removeEventListener('leavepictureinpicture', handleLeavePictureInPicture);\n    videoElement.removeEventListener(\n      'webkitcurrentplaybacktargetiswirelesschanged',\n      handleCurrentPlaybackTargetIsWirelessChanged\n    );\n    // $FlowFixMe: evt.availability is unknown to React.\n    videoElement.removeEventListener(\n      'webkitplaybacktargetavailabilitychanged',\n      handlePlaybackTargetAvailabilityChanged\n    );\n    videoElement.removeEventListener('webkitpresentationmodechanged', handlePresentationModeChanged);\n  }\n\n  return {\n    videoElementEventHandlers: {\n      onLoadStart,\n      onLoadedMetadata,\n      onCanPlay,\n      onWaiting,\n      onStalled,\n      onPlaying,\n      onPause,\n      onSeeking,\n      onSeeked,\n      onDurationChange,\n      onTimeUpdate,\n      onVolumeChange,\n      onProgress,\n      onError,\n      onEnded\n    },\n    pauseStreamRangeUpdater,\n    setLifeCycleManager,\n    isPipAvailable,\n    cleanup\n  };\n};\n\nexport default getBasicVideoEventHandlers;\n"]},"metadata":{},"sourceType":"script"}