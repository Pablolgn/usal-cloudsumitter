{"ast":null,"code":"/**\n * @author aleeper / http://adamleeper.com/\n * @author mrdoob / http://mrdoob.com/\n * @author gero3 / https://github.com/gero3\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  var loader = new THREE.STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n */\nmodule.exports = function (THREE) {\n  var STLLoader = function (manager) {\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n  };\n\n  STLLoader.prototype = {\n    constructor: THREE.STLLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new THREE.FileLoader(scope.manager);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (text) {\n        onLoad(scope.parse(text));\n      }, onProgress, onError);\n    },\n    parse: function (data) {\n      var isBinary = function () {\n        var expect, face_size, n_faces, reader;\n        reader = new DataView(binData);\n        face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n        n_faces = reader.getUint32(80, true);\n        expect = 80 + 32 / 8 + n_faces * face_size;\n\n        if (expect === reader.byteLength) {\n          return true;\n        } // An ASCII STL data must begin with 'solid ' as the first six bytes.\n        // However, ASCII STLs lacking the SPACE after the 'd' are known to be\n        // plentiful.  So, check the first 5 bytes for 'solid'.\n        // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\n        var solid = [115, 111, 108, 105, 100];\n\n        for (var i = 0; i < 5; i++) {\n          // If solid[ i ] does not match the i-th byte, then it is not an\n          // ASCII STL; hence, it is binary and return true.\n          if (solid[i] != reader.getUint8(i, false)) return true;\n        } // First 5 bytes read \"solid\"; declare it to be an ASCII STL\n\n\n        return false;\n      };\n\n      var binData = this.ensureBinary(data);\n      return isBinary() ? this.parseBinary(binData) : this.parseASCII(this.ensureString(data));\n    },\n    parseBinary: function (data) {\n      var reader = new DataView(data);\n      var faces = reader.getUint32(80, true);\n      var r,\n          g,\n          b,\n          hasColors = false,\n          colors;\n      var defaultR, defaultG, defaultB, alpha; // process STL header\n      // check for default color in header (\"COLOR=rgba\" sequence).\n\n      for (var index = 0; index < 80 - 10; index++) {\n        if (reader.getUint32(index, false) == 0x434F4C4F\n        /*COLO*/\n        && reader.getUint8(index + 4) == 0x52\n        /*'R'*/\n        && reader.getUint8(index + 5) == 0x3D\n        /*'='*/\n        ) {\n          hasColors = true;\n          colors = [];\n          defaultR = reader.getUint8(index + 6) / 255;\n          defaultG = reader.getUint8(index + 7) / 255;\n          defaultB = reader.getUint8(index + 8) / 255;\n          alpha = reader.getUint8(index + 9) / 255;\n        }\n      }\n\n      var dataOffset = 84;\n      var faceLength = 12 * 4 + 2;\n      var geometry = new THREE.BufferGeometry();\n      var vertices = [];\n      var normals = [];\n\n      for (var face = 0; face < faces; face++) {\n        var start = dataOffset + face * faceLength;\n        var normalX = reader.getFloat32(start, true);\n        var normalY = reader.getFloat32(start + 4, true);\n        var normalZ = reader.getFloat32(start + 8, true);\n\n        if (hasColors) {\n          var packedColor = reader.getUint16(start + 48, true);\n\n          if ((packedColor & 0x8000) === 0) {\n            // facet has its own unique color\n            r = (packedColor & 0x1F) / 31;\n            g = (packedColor >> 5 & 0x1F) / 31;\n            b = (packedColor >> 10 & 0x1F) / 31;\n          } else {\n            r = defaultR;\n            g = defaultG;\n            b = defaultB;\n          }\n        }\n\n        for (var i = 1; i <= 3; i++) {\n          var vertexstart = start + i * 12;\n          vertices.push(reader.getFloat32(vertexstart, true));\n          vertices.push(reader.getFloat32(vertexstart + 4, true));\n          vertices.push(reader.getFloat32(vertexstart + 8, true));\n          normals.push(normalX, normalY, normalZ);\n\n          if (hasColors) {\n            colors.push(r, g, b);\n          }\n        }\n      }\n\n      geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));\n      geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));\n\n      if (hasColors) {\n        geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));\n        geometry.hasColors = true;\n        geometry.alpha = alpha;\n      }\n\n      return geometry;\n    },\n    parseASCII: function (data) {\n      var geometry, length, patternFace, patternNormal, patternVertex, result, text;\n      geometry = new THREE.BufferGeometry();\n      patternFace = /facet([\\s\\S]*?)endfacet/g;\n      var vertices = [];\n      var normals = [];\n      var normal = new THREE.Vector3();\n\n      while ((result = patternFace.exec(data)) !== null) {\n        text = result[0];\n        patternNormal = /normal[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n        while ((result = patternNormal.exec(text)) !== null) {\n          normal.x = parseFloat(result[1]);\n          normal.y = parseFloat(result[3]);\n          normal.z = parseFloat(result[5]);\n        }\n\n        patternVertex = /vertex[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n        while ((result = patternVertex.exec(text)) !== null) {\n          vertices.push(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5]));\n          normals.push(normal.x, normal.y, normal.z);\n        }\n      }\n\n      geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));\n      geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));\n      return geometry;\n    },\n    ensureString: function (buf) {\n      if (typeof buf !== \"string\") {\n        var array_buffer = new Uint8Array(buf);\n        var strArray = [];\n\n        for (var i = 0; i < buf.byteLength; i++) {\n          strArray.push(String.fromCharCode(array_buffer[i])); // implicitly assumes little-endian\n        }\n\n        return strArray.join('');\n      } else {\n        return buf;\n      }\n    },\n    ensureBinary: function (buf) {\n      if (typeof buf === \"string\") {\n        var array_buffer = new Uint8Array(buf.length);\n\n        for (var i = 0; i < buf.length; i++) {\n          array_buffer[i] = buf.charCodeAt(i) & 0xff; // implicitly assumes little-endian\n        }\n\n        return array_buffer.buffer || array_buffer;\n      } else {\n        return buf;\n      }\n    }\n  };\n  return STLLoader;\n};","map":{"version":3,"sources":["/home/pablo/go/src/gitlab.com/Pablolgn/usal-cloudsubmitter/frontend/node_modules/three-stl-loader/index.js"],"names":["module","exports","THREE","STLLoader","manager","undefined","DefaultLoadingManager","prototype","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setResponseType","text","parse","data","isBinary","expect","face_size","n_faces","reader","DataView","binData","getUint32","byteLength","solid","i","getUint8","ensureBinary","parseBinary","parseASCII","ensureString","faces","r","g","b","hasColors","colors","defaultR","defaultG","defaultB","alpha","index","dataOffset","faceLength","geometry","BufferGeometry","vertices","normals","face","start","normalX","getFloat32","normalY","normalZ","packedColor","getUint16","vertexstart","push","addAttribute","BufferAttribute","Float32Array","length","patternFace","patternNormal","patternVertex","result","normal","Vector3","exec","x","parseFloat","y","z","buf","array_buffer","Uint8Array","strArray","String","fromCharCode","join","charCodeAt","buffer"],"mappings":"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","sourcesContent":["/**\n * @author aleeper / http://adamleeper.com/\n * @author mrdoob / http://mrdoob.com/\n * @author gero3 / https://github.com/gero3\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  var loader = new THREE.STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n */\n\n module.exports = function (THREE) {\n\n   var STLLoader = function ( manager ) {\n\n   \tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n   };\n\n   STLLoader.prototype = {\n\n   \tconstructor: THREE.STLLoader,\n\n   \tload: function ( url, onLoad, onProgress, onError ) {\n\n   \t\tvar scope = this;\n\n   \t\tvar loader = new THREE.FileLoader( scope.manager );\n   \t\tloader.setResponseType( 'arraybuffer' );\n   \t\tloader.load( url, function ( text ) {\n\n   \t\t\tonLoad( scope.parse( text ) );\n\n   \t\t}, onProgress, onError );\n\n   \t},\n\n   \tparse: function ( data ) {\n\n   \t\tvar isBinary = function () {\n\n   \t\t\tvar expect, face_size, n_faces, reader;\n   \t\t\treader = new DataView( binData );\n   \t\t\tface_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n   \t\t\tn_faces = reader.getUint32( 80, true );\n   \t\t\texpect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n   \t\t\tif ( expect === reader.byteLength ) {\n\n   \t\t\t\treturn true;\n\n   \t\t\t}\n\n   \t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n   \t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n   \t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n   \t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n   \t\t\tvar solid = [ 115, 111, 108, 105, 100 ];\n\n   \t\t\tfor ( var i = 0; i < 5; i ++ ) {\n\n   \t\t\t\t// If solid[ i ] does not match the i-th byte, then it is not an\n   \t\t\t\t// ASCII STL; hence, it is binary and return true.\n\n   \t\t\t\tif ( solid[ i ] != reader.getUint8( i, false ) ) return true;\n\n    \t\t\t}\n\n   \t\t\t// First 5 bytes read \"solid\"; declare it to be an ASCII STL\n   \t\t\treturn false;\n\n   \t\t};\n\n   \t\tvar binData = this.ensureBinary( data );\n\n   \t\treturn isBinary() ? this.parseBinary( binData ) : this.parseASCII( this.ensureString( data ) );\n\n   \t},\n\n   \tparseBinary: function ( data ) {\n\n   \t\tvar reader = new DataView( data );\n   \t\tvar faces = reader.getUint32( 80, true );\n\n   \t\tvar r, g, b, hasColors = false, colors;\n   \t\tvar defaultR, defaultG, defaultB, alpha;\n\n   \t\t// process STL header\n   \t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n   \t\tfor ( var index = 0; index < 80 - 10; index ++ ) {\n\n   \t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n   \t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n   \t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n   \t\t\t\thasColors = true;\n   \t\t\t\tcolors = [];\n\n   \t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n   \t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n   \t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n   \t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n   \t\t\t}\n\n   \t\t}\n\n   \t\tvar dataOffset = 84;\n   \t\tvar faceLength = 12 * 4 + 2;\n\n   \t\tvar geometry = new THREE.BufferGeometry();\n\n   \t\tvar vertices = [];\n   \t\tvar normals = [];\n\n   \t\tfor ( var face = 0; face < faces; face ++ ) {\n\n   \t\t\tvar start = dataOffset + face * faceLength;\n   \t\t\tvar normalX = reader.getFloat32( start, true );\n   \t\t\tvar normalY = reader.getFloat32( start + 4, true );\n   \t\t\tvar normalZ = reader.getFloat32( start + 8, true );\n\n   \t\t\tif ( hasColors ) {\n\n   \t\t\t\tvar packedColor = reader.getUint16( start + 48, true );\n\n   \t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n   \t\t\t\t\t// facet has its own unique color\n\n   \t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n   \t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n   \t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n   \t\t\t\t} else {\n\n   \t\t\t\t\tr = defaultR;\n   \t\t\t\t\tg = defaultG;\n   \t\t\t\t\tb = defaultB;\n\n   \t\t\t\t}\n\n   \t\t\t}\n\n   \t\t\tfor ( var i = 1; i <= 3; i ++ ) {\n\n   \t\t\t\tvar vertexstart = start + i * 12;\n\n   \t\t\t\tvertices.push( reader.getFloat32( vertexstart, true ) );\n   \t\t\t\tvertices.push( reader.getFloat32( vertexstart + 4, true ) );\n   \t\t\t\tvertices.push( reader.getFloat32( vertexstart + 8, true ) );\n\n   \t\t\t\tnormals.push( normalX, normalY, normalZ );\n\n   \t\t\t\tif ( hasColors ) {\n\n   \t\t\t\t\tcolors.push( r, g, b );\n\n   \t\t\t\t}\n\n   \t\t\t}\n\n   \t\t}\n\n   \t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( vertices ), 3 ) );\n   \t\tgeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( normals ), 3 ) );\n\n   \t\tif ( hasColors ) {\n\n   \t\t\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array( colors ), 3 ) );\n   \t\t\tgeometry.hasColors = true;\n   \t\t\tgeometry.alpha = alpha;\n\n   \t\t}\n\n   \t\treturn geometry;\n\n   \t},\n\n   \tparseASCII: function ( data ) {\n\n   \t\tvar geometry, length, patternFace, patternNormal, patternVertex, result, text;\n   \t\tgeometry = new THREE.BufferGeometry();\n   \t\tpatternFace = /facet([\\s\\S]*?)endfacet/g;\n\n   \t\tvar vertices = [];\n   \t\tvar normals = [];\n\n   \t\tvar normal = new THREE.Vector3();\n\n   \t\twhile ( ( result = patternFace.exec( data ) ) !== null ) {\n\n   \t\t\ttext = result[ 0 ];\n   \t\t\tpatternNormal = /normal[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n   \t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n   \t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n   \t\t\t\tnormal.y = parseFloat( result[ 3 ] );\n   \t\t\t\tnormal.z = parseFloat( result[ 5 ] );\n\n   \t\t\t}\n\n   \t\t\tpatternVertex = /vertex[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n   \t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n   \t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 3 ] ), parseFloat( result[ 5 ] ) );\n   \t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n   \t\t\t}\n\n   \t\t}\n\n   \t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( vertices ), 3 ) );\n   \t\tgeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( normals ), 3 ) );\n\n   \t\treturn geometry;\n\n   \t},\n\n   \tensureString: function ( buf ) {\n\n   \t\tif ( typeof buf !== \"string\" ) {\n\n   \t\t\tvar array_buffer = new Uint8Array( buf );\n   \t\t\tvar strArray = [];\n   \t\t\tfor ( var i = 0; i < buf.byteLength; i ++ ) {\n\n   \t\t\t\tstrArray.push(String.fromCharCode( array_buffer[ i ] )); // implicitly assumes little-endian\n\n   \t\t\t}\n   \t\t\treturn strArray.join('');\n\n   \t\t} else {\n\n   \t\t\treturn buf;\n\n   \t\t}\n\n   \t},\n\n   \tensureBinary: function ( buf ) {\n\n   \t\tif ( typeof buf === \"string\" ) {\n\n   \t\t\tvar array_buffer = new Uint8Array( buf.length );\n   \t\t\tfor ( var i = 0; i < buf.length; i ++ ) {\n\n   \t\t\t\tarray_buffer[ i ] = buf.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n   \t\t\t}\n   \t\t\treturn array_buffer.buffer || array_buffer;\n\n   \t\t} else {\n\n   \t\t\treturn buf;\n\n   \t\t}\n\n   \t}\n\n   }\n\n   return STLLoader\n }\n"]},"metadata":{},"sourceType":"script"}